{
  if (temporalInfo != null && (temporalInfo.getStartTime() == null || temporalInfo.getEndTime() == null)) {
    return Collections.emptySet();
  }
  for (  Map.Entry<String,Set<Resource>> resourceEntry : resources.entrySet()) {
    String hostname=resourceEntry.getKey();
    Set<Resource> resourceSet=resourceEntry.getValue();
    for (    Resource resource : resourceSet) {
      String clusterName=(String)resource.getPropertyValue(clusterNamePropertyId);
      if (!hostProvider.isCollectorHostLive(clusterName,TIMELINE_METRICS)) {
        LOG.info("METRICS_COLLECTOR host is not live. Skip populating " + "resources with metrics.");
        return Collections.emptySet();
      }
      if (!hostProvider.isCollectorComponentLive(clusterName,TIMELINE_METRICS)) {
        LOG.info("METRICS_COLLECTOR is not live. Skip populating resources" + " with metrics.");
        return Collections.emptySet();
      }
      String spec=getSpec(hostname,resource);
      BufferedReader reader=null;
      try {
        LOG.debug("Metrics request url =" + spec);
        reader=new BufferedReader(new InputStreamReader(streamProvider.readFrom(spec)));
        TimelineMetrics timelineMetrics=timelineObjectReader.readValue(reader);
        LOG.debug("Timeline metrics response => " + timelineMetrics);
        Set<String> patterns=createPatterns(metrics.keySet());
        for (        TimelineMetric metric : timelineMetrics.getMetrics()) {
          if (metric.getMetricName() != null && metric.getMetricValues() != null && checkMetricName(patterns,metric.getMetricName())) {
            populateResource(resource,metric);
          }
        }
      }
 catch (      IOException io) {
        String errorMsg="Error getting timeline metrics.";
        if (LOG.isDebugEnabled()) {
          LOG.error(errorMsg,io);
        }
 else {
          if (io instanceof SocketTimeoutException) {
            errorMsg+=" Can not connect to collector, socket error.";
          }
          LOG.error(errorMsg);
        }
      }
 finally {
        if (reader != null) {
          try {
            reader.close();
          }
 catch (          IOException e) {
            if (LOG.isWarnEnabled()) {
              if (LOG.isDebugEnabled()) {
                LOG.warn("Unable to close http input stream : spec=" + spec,e);
              }
 else {
                LOG.warn("Unable to close http input stream : spec=" + spec);
              }
            }
          }
        }
      }
    }
  }
  return Collections.emptySet();
}
