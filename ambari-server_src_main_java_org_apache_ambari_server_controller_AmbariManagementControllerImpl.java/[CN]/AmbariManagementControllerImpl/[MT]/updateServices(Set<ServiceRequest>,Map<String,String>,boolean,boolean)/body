{
  if (requests.isEmpty()) {
    LOG.warn("Received an empty requests set");
    return null;
  }
  Map<State,List<Service>> changedServices=new HashMap<State,List<Service>>();
  Map<State,List<ServiceComponent>> changedComps=new HashMap<State,List<ServiceComponent>>();
  Map<String,Map<State,List<ServiceComponentHost>>> changedScHosts=new HashMap<String,Map<State,List<ServiceComponentHost>>>();
  Collection<ServiceComponentHost> ignoredScHosts=new ArrayList<ServiceComponentHost>();
  Set<String> clusterNames=new HashSet<String>();
  Map<String,Set<String>> serviceNames=new HashMap<String,Set<String>>();
  Set<State> seenNewStates=new HashSet<State>();
  for (  ServiceRequest request : requests) {
    if (request.getClusterName() == null || request.getClusterName().isEmpty() || request.getServiceName() == null || request.getServiceName().isEmpty()) {
      throw new IllegalArgumentException("Invalid arguments, cluster name" + " and service name should be provided to update services");
    }
    LOG.info("Received a updateService request" + ", clusterName=" + request.getClusterName() + ", serviceName="+ request.getServiceName()+ ", request="+ request.toString());
    clusterNames.add(request.getClusterName());
    if (clusterNames.size() > 1) {
      throw new IllegalArgumentException("Updates to multiple clusters is not" + " supported");
    }
    if (!serviceNames.containsKey(request.getClusterName())) {
      serviceNames.put(request.getClusterName(),new HashSet<String>());
    }
    if (serviceNames.get(request.getClusterName()).contains(request.getServiceName())) {
      throw new IllegalArgumentException("Invalid request contains duplicate" + " service names");
    }
    serviceNames.get(request.getClusterName()).add(request.getServiceName());
    Cluster cluster=clusters.getCluster(request.getClusterName());
    Service s=cluster.getService(request.getServiceName());
    State oldState=s.getDesiredState();
    State newState=null;
    if (request.getDesiredState() != null) {
      newState=State.valueOf(request.getDesiredState());
      if (!newState.isValidDesiredState()) {
        throw new IllegalArgumentException("Invalid arguments, invalid" + " desired state, desiredState=" + newState);
      }
    }
    if (request.getConfigVersions() != null) {
      safeToUpdateConfigsForService(s,oldState,newState);
      for (      Entry<String,String> entry : request.getConfigVersions().entrySet()) {
        if (LOG.isDebugEnabled()) {
          LOG.debug("Attaching config to service" + ", clusterName=" + cluster.getClusterName() + ", serviceName="+ s.getName()+ ", configType="+ entry.getKey()+ ", configTag="+ entry.getValue());
        }
        Config config=cluster.getConfig(entry.getKey(),entry.getValue());
        if (null == config) {
          throw new AmbariException("Trying to update service with" + " invalid configs" + ", clusterName=" + cluster.getClusterName() + ", clusterId="+ cluster.getClusterId()+ ", serviceName="+ s.getName()+ ", invalidConfigType="+ entry.getKey()+ ", invalidConfigTag="+ entry.getValue());
        }
      }
    }
    if (newState == null) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("Nothing to do for new updateService request" + ", clusterName=" + request.getClusterName() + ", serviceName="+ request.getServiceName()+ ", newDesiredState=null");
      }
      continue;
    }
    seenNewStates.add(newState);
    if (newState != oldState) {
      if (!isValidDesiredStateTransition(oldState,newState)) {
        throw new AmbariException("Invalid transition for" + " service" + ", clusterName=" + cluster.getClusterName() + ", clusterId="+ cluster.getClusterId()+ ", serviceName="+ s.getName()+ ", currentDesiredState="+ oldState+ ", newDesiredState="+ newState);
      }
      if (!changedServices.containsKey(newState)) {
        changedServices.put(newState,new ArrayList<Service>());
      }
      changedServices.get(newState).add(s);
    }
    for (    ServiceComponent sc : s.getServiceComponents().values()) {
      State oldScState=sc.getDesiredState();
      if (newState != oldScState) {
        if (sc.isClientComponent() && !newState.isValidClientComponentState()) {
          continue;
        }
        if (!isValidDesiredStateTransition(oldScState,newState)) {
          throw new AmbariException("Invalid transition for" + " servicecomponent" + ", clusterName=" + cluster.getClusterName() + ", clusterId="+ cluster.getClusterId()+ ", serviceName="+ sc.getServiceName()+ ", componentName="+ sc.getName()+ ", currentDesiredState="+ oldScState+ ", newDesiredState="+ newState);
        }
        if (!changedComps.containsKey(newState)) {
          changedComps.put(newState,new ArrayList<ServiceComponent>());
        }
        changedComps.get(newState).add(sc);
      }
      if (LOG.isDebugEnabled()) {
        LOG.debug("Handling update to ServiceComponent" + ", clusterName=" + request.getClusterName() + ", serviceName="+ s.getName()+ ", componentName="+ sc.getName()+ ", currentDesiredState="+ oldScState+ ", newDesiredState="+ newState);
      }
      for (      ServiceComponentHost sch : sc.getServiceComponentHosts().values()) {
        State oldSchState=sch.getState();
        if (oldSchState == State.MAINTENANCE || oldSchState == State.UNKNOWN) {
          if (LOG.isDebugEnabled()) {
            LOG.debug("Ignoring ServiceComponentHost" + ", clusterName=" + request.getClusterName() + ", serviceName="+ s.getName()+ ", componentName="+ sc.getName()+ ", hostname="+ sch.getHostName()+ ", currentState="+ oldSchState+ ", newDesiredState="+ newState);
          }
          continue;
        }
        if (newState == oldSchState) {
          ignoredScHosts.add(sch);
          if (LOG.isDebugEnabled()) {
            LOG.debug("Ignoring ServiceComponentHost" + ", clusterName=" + request.getClusterName() + ", serviceName="+ s.getName()+ ", componentName="+ sc.getName()+ ", hostname="+ sch.getHostName()+ ", currentState="+ oldSchState+ ", newDesiredState="+ newState);
          }
          continue;
        }
        if (sc.isClientComponent() && !newState.isValidClientComponentState()) {
          continue;
        }
        if (!isValidStateTransition(oldSchState,newState)) {
          String error="Invalid transition for" + " servicecomponenthost" + ", clusterName=" + cluster.getClusterName() + ", clusterId="+ cluster.getClusterId()+ ", serviceName="+ sch.getServiceName()+ ", componentName="+ sch.getServiceComponentName()+ ", hostname="+ sch.getHostName()+ ", currentState="+ oldSchState+ ", newDesiredState="+ newState;
          StackId sid=cluster.getDesiredStackVersion();
          if (ambariMetaInfo.getComponentCategory(sid.getStackName(),sid.getStackVersion(),sc.getServiceName(),sch.getServiceComponentName()).isMaster()) {
            throw new AmbariException(error);
          }
 else {
            LOG.warn("Ignoring: " + error);
            continue;
          }
        }
        if (!changedScHosts.containsKey(sc.getName())) {
          changedScHosts.put(sc.getName(),new HashMap<State,List<ServiceComponentHost>>());
        }
        if (!changedScHosts.get(sc.getName()).containsKey(newState)) {
          changedScHosts.get(sc.getName()).put(newState,new ArrayList<ServiceComponentHost>());
        }
        if (LOG.isDebugEnabled()) {
          LOG.debug("Handling update to ServiceComponentHost" + ", clusterName=" + request.getClusterName() + ", serviceName="+ s.getName()+ ", componentName="+ sc.getName()+ ", hostname="+ sch.getHostName()+ ", currentState="+ oldSchState+ ", newDesiredState="+ newState);
        }
        changedScHosts.get(sc.getName()).get(newState).add(sch);
      }
    }
  }
  if (seenNewStates.size() > 1) {
    throw new IllegalArgumentException("Cannot handle different desired state" + " changes for a set of services at the same time");
  }
  for (  ServiceRequest request : requests) {
    Cluster cluster=clusters.getCluster(request.getClusterName());
    Service s=cluster.getService(request.getServiceName());
    if (request.getConfigVersions() != null) {
      Map<String,Config> updated=new HashMap<String,Config>();
      for (      Entry<String,String> entry : request.getConfigVersions().entrySet()) {
        Config config=cluster.getConfig(entry.getKey(),entry.getValue());
        updated.put(config.getType(),config);
      }
      if (!updated.isEmpty()) {
        if (LOG.isDebugEnabled()) {
          LOG.debug("Updating service configs, attaching configs" + ", clusterName=" + request.getClusterName() + ", serviceName="+ s.getName()+ ", configCount="+ updated.size());
        }
        s.updateDesiredConfigs(updated);
        s.persist();
      }
      for (      ServiceComponent sc : s.getServiceComponents().values()) {
        sc.deleteDesiredConfigs(updated.keySet());
        for (        ServiceComponentHost sch : sc.getServiceComponentHosts().values()) {
          sch.deleteDesiredConfigs(updated.keySet());
          sch.persist();
        }
        sc.persist();
      }
    }
  }
  Cluster cluster=clusters.getCluster(clusterNames.iterator().next());
  List<Stage> stages=doStageCreation(cluster,changedServices,changedComps,changedScHosts,null,requestProperties.get(REQUEST_CONTEXT_PROPERTY),runSmokeTest,reconfigureClients);
  persistStages(stages);
  updateServiceStates(changedServices,changedComps,changedScHosts,ignoredScHosts);
  if (stages == null || stages.isEmpty()) {
    return null;
  }
  return getRequestStatusResponse(stages.get(0).getRequestId());
}
