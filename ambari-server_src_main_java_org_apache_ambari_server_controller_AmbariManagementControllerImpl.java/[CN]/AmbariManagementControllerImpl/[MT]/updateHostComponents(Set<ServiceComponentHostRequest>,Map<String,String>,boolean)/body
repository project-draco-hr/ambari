{
  if (requests.isEmpty()) {
    LOG.warn("Received an empty requests set");
    return null;
  }
  Map<String,Map<State,List<ServiceComponentHost>>> changedScHosts=new HashMap<String,Map<State,List<ServiceComponentHost>>>();
  Set<String> clusterNames=new HashSet<String>();
  Map<String,Map<String,Map<String,Set<String>>>> hostComponentNames=new HashMap<String,Map<String,Map<String,Set<String>>>>();
  Set<State> seenNewStates=new HashSet<State>();
  boolean processingUpgradeRequest=false;
  int numberOfRequestsProcessed=0;
  StackId fromStackVersion=new StackId();
  Map<ServiceComponentHost,State> directTransitionScHosts=new HashMap<ServiceComponentHost,State>();
  for (  ServiceComponentHostRequest request : requests) {
    numberOfRequestsProcessed++;
    validateServiceComponentHostRequest(request);
    Cluster cluster=clusters.getCluster(request.getClusterName());
    if (StringUtils.isEmpty(request.getServiceName())) {
      request.setServiceName(findServiceName(cluster,request.getComponentName()));
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug("Received a createHostComponent request" + ", clusterName=" + request.getClusterName() + ", serviceName="+ request.getServiceName()+ ", componentName="+ request.getComponentName()+ ", hostname="+ request.getHostname()+ ", request="+ request);
    }
    clusterNames.add(request.getClusterName());
    if (clusterNames.size() > 1) {
      throw new IllegalArgumentException("Updates to multiple clusters is not" + " supported");
    }
    if (!hostComponentNames.containsKey(request.getClusterName())) {
      hostComponentNames.put(request.getClusterName(),new HashMap<String,Map<String,Set<String>>>());
    }
    if (!hostComponentNames.get(request.getClusterName()).containsKey(request.getServiceName())) {
      hostComponentNames.get(request.getClusterName()).put(request.getServiceName(),new HashMap<String,Set<String>>());
    }
    if (!hostComponentNames.get(request.getClusterName()).get(request.getServiceName()).containsKey(request.getComponentName())) {
      hostComponentNames.get(request.getClusterName()).get(request.getServiceName()).put(request.getComponentName(),new HashSet<String>());
    }
    if (hostComponentNames.get(request.getClusterName()).get(request.getServiceName()).get(request.getComponentName()).contains(request.getHostname())) {
      throw new IllegalArgumentException("Invalid request contains duplicate" + " hostcomponents");
    }
    hostComponentNames.get(request.getClusterName()).get(request.getServiceName()).get(request.getComponentName()).add(request.getHostname());
    Service s=cluster.getService(request.getServiceName());
    ServiceComponent sc=s.getServiceComponent(request.getComponentName());
    ServiceComponentHost sch=sc.getServiceComponentHost(request.getHostname());
    State oldState=sch.getState();
    State newState=null;
    if (request.getDesiredState() != null) {
      newState=State.valueOf(request.getDesiredState());
      if (!newState.isValidDesiredState()) {
        throw new IllegalArgumentException("Invalid arguments, invalid" + " desired state, desiredState=" + newState.toString());
      }
    }
    if (request.getConfigVersions() != null) {
      safeToUpdateConfigsForServiceComponentHost(sch,oldState,newState);
      for (      Entry<String,String> entry : request.getConfigVersions().entrySet()) {
        Config config=cluster.getConfig(entry.getKey(),entry.getValue());
        if (null == config) {
          throw new AmbariException("Trying to update servicecomponenthost" + " with invalid configs" + ", clusterName=" + cluster.getClusterName() + ", clusterId="+ cluster.getClusterId()+ ", serviceName="+ s.getName()+ ", componentName="+ sc.getName()+ ", hostname="+ sch.getHostName()+ ", invalidConfigType="+ entry.getKey()+ ", invalidConfigTag="+ entry.getValue());
        }
      }
    }
    boolean upgradeRequest=checkIfUpgradeRequestAndValidate(request,cluster,s,sc,sch);
    if (newState == null) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("Nothing to do for new updateServiceComponentHost request" + ", clusterName=" + request.getClusterName() + ", serviceName="+ request.getServiceName()+ ", componentName="+ request.getComponentName()+ ", hostname="+ request.getHostname()+ ", newDesiredState=null");
      }
      continue;
    }
    if (sc.isClientComponent() && !newState.isValidClientComponentState()) {
      throw new IllegalArgumentException("Invalid desired state for a client" + " component");
    }
    seenNewStates.add(newState);
    if (!processingUpgradeRequest && upgradeRequest) {
      processingUpgradeRequest=true;
      if (numberOfRequestsProcessed > 1) {
        throw new AmbariException("An upgrade request cannot be combined with " + "other non-upgrade requests.");
      }
      fromStackVersion=sch.getStackVersion();
    }
    if (processingUpgradeRequest) {
      if (!upgradeRequest) {
        throw new AmbariException("An upgrade request cannot be combined with " + "other non-upgrade requests.");
      }
      sch.setState(State.UPGRADING);
      sch.setDesiredStackVersion(cluster.getCurrentStackVersion());
    }
    State oldSchState=sch.getState();
    if (newState == oldSchState) {
      sch.setDesiredState(newState);
      if (LOG.isDebugEnabled()) {
        LOG.debug("Ignoring ServiceComponentHost" + ", clusterName=" + request.getClusterName() + ", serviceName="+ s.getName()+ ", componentName="+ sc.getName()+ ", hostname="+ sch.getHostName()+ ", currentState="+ oldSchState+ ", newDesiredState="+ newState);
      }
      continue;
    }
    if (!isValidStateTransition(oldSchState,newState)) {
      throw new AmbariException("Invalid transition for" + " servicecomponenthost" + ", clusterName=" + cluster.getClusterName() + ", clusterId="+ cluster.getClusterId()+ ", serviceName="+ sch.getServiceName()+ ", componentName="+ sch.getServiceComponentName()+ ", hostname="+ sch.getHostName()+ ", currentState="+ oldSchState+ ", newDesiredState="+ newState);
    }
    if (isDirectTransition(oldSchState,newState)) {
      if (LOG.isDebugEnabled()) {
        LOG.debug("Handling direct transition update to ServiceComponentHost" + ", clusterName=" + request.getClusterName() + ", serviceName="+ s.getName()+ ", componentName="+ sc.getName()+ ", hostname="+ sch.getHostName()+ ", currentState="+ oldSchState+ ", newDesiredState="+ newState);
      }
      directTransitionScHosts.put(sch,newState);
    }
 else {
      if (!changedScHosts.containsKey(sc.getName())) {
        changedScHosts.put(sc.getName(),new HashMap<State,List<ServiceComponentHost>>());
      }
      if (!changedScHosts.get(sc.getName()).containsKey(newState)) {
        changedScHosts.get(sc.getName()).put(newState,new ArrayList<ServiceComponentHost>());
      }
      if (LOG.isDebugEnabled()) {
        LOG.debug("Handling update to ServiceComponentHost" + ", clusterName=" + request.getClusterName() + ", serviceName="+ s.getName()+ ", componentName="+ sc.getName()+ ", hostname="+ sch.getHostName()+ ", currentState="+ oldSchState+ ", newDesiredState="+ newState);
      }
      changedScHosts.get(sc.getName()).get(newState).add(sch);
    }
  }
  if (seenNewStates.size() > 1) {
    throw new IllegalArgumentException("Cannot handle different desired" + " state changes for a set of service components at the same time");
  }
  for (  ServiceComponentHostRequest request : requests) {
    Cluster cluster=clusters.getCluster(request.getClusterName());
    Service s=cluster.getService(request.getServiceName());
    ServiceComponent sc=s.getServiceComponent(request.getComponentName());
    ServiceComponentHost sch=sc.getServiceComponentHost(request.getHostname());
    if (request.getConfigVersions() != null) {
      Map<String,Config> updated=new HashMap<String,Config>();
      for (      Entry<String,String> entry : request.getConfigVersions().entrySet()) {
        Config config=cluster.getConfig(entry.getKey(),entry.getValue());
        updated.put(config.getType(),config);
        if (!updated.isEmpty()) {
          sch.updateDesiredConfigs(updated);
        }
      }
    }
  }
  for (  Entry<ServiceComponentHost,State> entry : directTransitionScHosts.entrySet()) {
    ServiceComponentHost componentHost=entry.getKey();
    State newState=entry.getValue();
    long timestamp=System.currentTimeMillis();
    ServiceComponentHostEvent event;
    componentHost.setDesiredState(newState);
switch (newState) {
case MAINTENANCE:
      event=new ServiceComponentHostMaintenanceEvent(componentHost.getServiceComponentName(),componentHost.getHostName(),timestamp);
    break;
case INSTALLED:
  event=new ServiceComponentHostRestoreEvent(componentHost.getServiceComponentName(),componentHost.getHostName(),timestamp);
break;
default :
throw new AmbariException("Direct transition from " + componentHost.getState() + " to "+ newState+ " not supported");
}
try {
componentHost.handleEvent(event);
}
 catch (InvalidStateTransitionException e) {
throw new AmbariException("Internal error - not supported transition",e);
}
}
Cluster cluster=clusters.getCluster(clusterNames.iterator().next());
Map<String,String> requestParameters=null;
if (processingUpgradeRequest) {
requestParameters=new HashMap<String,String>();
requestParameters.put(Configuration.UPGRADE_TO_STACK,gson.toJson(cluster.getCurrentStackVersion()));
requestParameters.put(Configuration.UPGRADE_FROM_STACK,gson.toJson(fromStackVersion));
}
List<Stage> stages=doStageCreation(cluster,null,null,changedScHosts,requestParameters,requestProperties.get(REQUEST_CONTEXT_PROPERTY),runSmokeTest,false);
persistStages(stages);
updateServiceStates(null,null,changedScHosts);
if (stages == null || stages.isEmpty()) {
return null;
}
return getRequestStatusResponse(stages.get(0).getRequestId());
}
