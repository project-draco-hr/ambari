{
  int startingTime=10000;
  clock.setTime(startingTime);
  long timeOfFirstStep=clock.getTime();
  long sleep=agg.runOnce(sleepIntervalMillis);
  assertEquals("startTime should be zero",0,startTimeInDoWork.get());
  assertEquals("endTime  should be zero",0,endTimeInDoWork.get());
  assertEquals("do not aggregate on first run",0,actualRuns);
  assertEquals("first checkpoint set on current time",timeOfFirstStep,checkPoint.get());
  assertEquals(sleep,sleepIntervalMillis);
  clock.setTime(timeOfFirstStep + 1);
  long timeOfSecondStep=clock.getTime();
  sleep=agg.runOnce(sleepIntervalMillis);
  assertEquals("startTime should be on previous checkpoint since it did not" + " run yet",timeOfFirstStep,startTimeInDoWork.get());
  assertEquals("endTime can be start + interval",startingTime + sleepIntervalMillis,endTimeInDoWork.get());
  assertEquals("should aggregate",1,actualRuns);
  assertEquals("checkpoint here should be set to min(endTime,currentTime), " + "it is currentTime in our scenario",timeOfSecondStep,checkPoint.get());
  assertEquals(sleep,sleepIntervalMillis);
  clock.setTime(startingTime + 2);
  long timeOfThirdStep=clock.getTime();
  sleep=agg.runOnce(sleepIntervalMillis);
  assertEquals("startTime should be previous checkpoint",timeOfSecondStep,startTimeInDoWork.get());
  assertEquals("endTime  can be start + interval",timeOfSecondStep + sleepIntervalMillis,endTimeInDoWork.get());
  assertEquals("should aggregate",2,actualRuns);
  assertEquals("checkpoint here should be set to min(endTime,currentTime), " + "it is currentTime in our scenario",timeOfThirdStep,checkPoint.get());
  assertEquals(sleep,sleepIntervalMillis);
}
