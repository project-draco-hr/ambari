{
  Iterator<Map<String,Object>> iterator=request.getProperties().iterator();
  String clName;
  final String desiredRepoVersion;
  String stackName;
  String stackVersion;
  if (request.getProperties().size() != 1) {
    throw new UnsupportedOperationException("Multiple requests cannot be executed at the same time.");
  }
  Map<String,Object> propertyMap=iterator.next();
  Set<String> requiredProperties=new HashSet<String>(){
{
      add(CLUSTER_STACK_VERSION_CLUSTER_NAME_PROPERTY_ID);
      add(CLUSTER_STACK_VERSION_REPOSITORY_VERSION_PROPERTY_ID);
      add(CLUSTER_STACK_VERSION_STACK_PROPERTY_ID);
      add(CLUSTER_STACK_VERSION_VERSION_PROPERTY_ID);
    }
  }
;
  for (  String requiredProperty : requiredProperties) {
    if (!propertyMap.containsKey(requiredProperty)) {
      throw new IllegalArgumentException(String.format("The required property %s is not defined",requiredProperty));
    }
  }
  clName=(String)propertyMap.get(CLUSTER_STACK_VERSION_CLUSTER_NAME_PROPERTY_ID);
  desiredRepoVersion=(String)propertyMap.get(CLUSTER_STACK_VERSION_REPOSITORY_VERSION_PROPERTY_ID);
  Cluster cluster;
  Map<String,Host> hostsForCluster;
  AmbariManagementController managementController=getManagementController();
  AmbariMetaInfo ami=managementController.getAmbariMetaInfo();
  try {
    cluster=managementController.getClusters().getCluster(clName);
    hostsForCluster=managementController.getClusters().getHostsForCluster(clName);
  }
 catch (  AmbariException e) {
    throw new NoSuchParentResourceException(e.getMessage(),e);
  }
  String stackId;
  if (propertyMap.containsKey(CLUSTER_STACK_VERSION_STACK_PROPERTY_ID) && propertyMap.containsKey(CLUSTER_STACK_VERSION_VERSION_PROPERTY_ID)) {
    stackName=(String)propertyMap.get(CLUSTER_STACK_VERSION_STACK_PROPERTY_ID);
    stackVersion=(String)propertyMap.get(CLUSTER_STACK_VERSION_VERSION_PROPERTY_ID);
    stackId=new StackId(stackName,stackVersion).getStackId();
    if (!ami.isSupportedStack(stackName,stackVersion)) {
      throw new NoSuchParentResourceException(String.format("Stack %s is not supported",stackId));
    }
  }
 else {
    StackId currentStackVersion=cluster.getCurrentStackVersion();
    stackName=currentStackVersion.getStackName();
    stackVersion=currentStackVersion.getStackVersion();
    stackId=currentStackVersion.getStackId();
  }
  RepositoryVersionEntity repoVersionEnt=repositoryVersionDAO.findByStackAndVersion(stackId,desiredRepoVersion);
  if (repoVersionEnt == null) {
    throw new IllegalArgumentException(String.format("Repo version %s is not available for stack %s",desiredRepoVersion,stackId));
  }
  List<OperatingSystemEntity> operatingSystems=repoVersionEnt.getOperatingSystems();
  Map<String,List<RepositoryEntity>> perOsRepos=new HashMap<String,List<RepositoryEntity>>();
  for (  OperatingSystemEntity operatingSystem : operatingSystems) {
    perOsRepos.put(operatingSystem.getOsType(),operatingSystem.getRepositories());
  }
  RequestStageContainer req=createRequest();
  String stageName=String.format(INSTALL_PACKAGES_FULL_NAME);
  Map<String,String> hostLevelParams=new HashMap<String,String>();
  hostLevelParams.put(JDK_LOCATION,getManagementController().getJdkResourceUrl());
  Stage stage=stageFactory.createNew(req.getId(),"/tmp/ambari",cluster.getClusterName(),cluster.getClusterId(),stageName,"{}","{}",StageUtils.getGson().toJson(hostLevelParams));
  long stageId=req.getLastStageId() + 1;
  if (0L == stageId) {
    stageId=1L;
  }
  stage.setStageId(stageId);
  req.addStages(Collections.singletonList(stage));
  for (  Host host : hostsForCluster.values()) {
    final List<RepositoryEntity> repoInfo=perOsRepos.get(host.getOsFamily());
    if (repoInfo == null) {
      throw new SystemException(String.format("Repositories for os type %s are " + "not defined. Repo version=%s, stackId=%s",host.getOsFamily(),desiredRepoVersion,stackId));
    }
    List<ServiceOsSpecific.Package> packages=new ArrayList<ServiceOsSpecific.Package>();
    Set<String> servicesOnHost=new HashSet<String>();
    List<ServiceComponentHost> components=cluster.getServiceComponentHosts(host.getHostName());
    for (    ServiceComponentHost component : components) {
      servicesOnHost.add(component.getServiceName());
    }
    for (    String serviceName : servicesOnHost) {
      ServiceInfo info;
      try {
        info=ami.getService(stackName,stackVersion,serviceName);
      }
 catch (      AmbariException e) {
        throw new SystemException("Cannot enumerate services",e);
      }
      List<ServiceOsSpecific.Package> packagesForService=managementController.getPackagesForServiceHost(info,new HashMap<String,String>(),host.getOsFamily());
      packages.addAll(packagesForService);
    }
    final String packageList=gson.toJson(packages);
    final String repoList=gson.toJson(repoInfo);
    Map<String,String> params=new HashMap<String,String>(){
{
        put("repository_version",desiredRepoVersion);
        put("base_urls",repoList);
        put("package_list",packageList);
      }
    }
;
    RequestResourceFilter filter=new RequestResourceFilter(null,null,Collections.singletonList(host.getHostName()));
    ActionExecutionContext actionContext=new ActionExecutionContext(cluster.getClusterName(),INSTALL_PACKAGES_ACTION,Collections.singletonList(filter),params);
    actionContext.setTimeout(Short.valueOf(configuration.getDefaultAgentTaskTimeout()));
    try {
      actionExecutionHelper.get().addExecutionCommandsToStage(actionContext,stage,false);
    }
 catch (    AmbariException e) {
      throw new SystemException("Can not modify stage",e);
    }
  }
  try {
    ClusterVersionEntity existingCSVer=clusterVersionDAO.findByClusterAndStackAndVersion(clName,stackId,desiredRepoVersion);
    if (existingCSVer == null) {
      try {
        cluster.createClusterVersion(stackId,desiredRepoVersion,managementController.getAuthName(),RepositoryVersionState.INSTALLING);
        existingCSVer=clusterVersionDAO.findByClusterAndStackAndVersion(clName,stackId,desiredRepoVersion);
      }
 catch (      AmbariException e) {
        throw new SystemException(String.format("Can not create cluster stack version %s for cluster %s",desiredRepoVersion,clName),e);
      }
    }
 else {
      cluster.transitionClusterVersion(stackId,desiredRepoVersion,RepositoryVersionState.INSTALLING);
    }
    cluster.inferHostVersions(existingCSVer);
    req.persist();
  }
 catch (  AmbariException e) {
    throw new SystemException("Can not persist request",e);
  }
  return getRequestStatus(req.getRequestStatusResponse());
}
