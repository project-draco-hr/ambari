{
  if (request.getProperties().size() > 1) {
    throw new UnsupportedOperationException("Multiple requests cannot be executed at the same time.");
  }
  Iterator<Map<String,Object>> iterator=request.getProperties().iterator();
  String clName;
  final String desiredRepoVersion;
  String stackName;
  String stackVersion;
  Map<String,Object> propertyMap=iterator.next();
  Set<String> requiredProperties=new HashSet<String>();
  requiredProperties.add(CLUSTER_STACK_VERSION_CLUSTER_NAME_PROPERTY_ID);
  requiredProperties.add(CLUSTER_STACK_VERSION_REPOSITORY_VERSION_PROPERTY_ID);
  requiredProperties.add(CLUSTER_STACK_VERSION_STACK_PROPERTY_ID);
  requiredProperties.add(CLUSTER_STACK_VERSION_VERSION_PROPERTY_ID);
  for (  String requiredProperty : requiredProperties) {
    if (!propertyMap.containsKey(requiredProperty)) {
      throw new IllegalArgumentException(String.format("The required property %s is not defined",requiredProperty));
    }
  }
  clName=(String)propertyMap.get(CLUSTER_STACK_VERSION_CLUSTER_NAME_PROPERTY_ID);
  desiredRepoVersion=(String)propertyMap.get(CLUSTER_STACK_VERSION_REPOSITORY_VERSION_PROPERTY_ID);
  Cluster cluster;
  AmbariManagementController managementController=getManagementController();
  AmbariMetaInfo ami=managementController.getAmbariMetaInfo();
  try {
    Clusters clusters=managementController.getClusters();
    cluster=clusters.getCluster(clName);
  }
 catch (  AmbariException e) {
    throw new NoSuchParentResourceException(e.getMessage(),e);
  }
  UpgradeEntity entity=cluster.getUpgradeInProgress();
  if (null != entity) {
    throw new IllegalArgumentException(String.format("Cluster %s %s is in progress.  Cannot install packages.",cluster.getClusterName(),entity.getDirection().getText(false)));
  }
  List<Host> hosts=getHostsForStackDistribution(cluster);
  final StackId stackId;
  if (propertyMap.containsKey(CLUSTER_STACK_VERSION_STACK_PROPERTY_ID) && propertyMap.containsKey(CLUSTER_STACK_VERSION_VERSION_PROPERTY_ID)) {
    stackName=(String)propertyMap.get(CLUSTER_STACK_VERSION_STACK_PROPERTY_ID);
    stackVersion=(String)propertyMap.get(CLUSTER_STACK_VERSION_VERSION_PROPERTY_ID);
    stackId=new StackId(stackName,stackVersion);
    if (!ami.isSupportedStack(stackName,stackVersion)) {
      throw new NoSuchParentResourceException(String.format("Stack %s is not supported",stackId));
    }
  }
 else {
    StackId currentStackVersion=cluster.getCurrentStackVersion();
    stackId=currentStackVersion;
  }
  Float successFactor=INSTALL_PACKAGES_SUCCESS_FACTOR;
  String successFactorProperty=(String)propertyMap.get(CLUSTER_STACK_VERSION_STAGE_SUCCESS_FACTOR);
  if (StringUtils.isNotBlank(successFactorProperty)) {
    successFactor=Float.valueOf(successFactorProperty);
  }
  RepositoryVersionEntity repoVersionEnt=repositoryVersionDAO.findByStackAndVersion(stackId,desiredRepoVersion);
  if (repoVersionEnt == null) {
    throw new IllegalArgumentException(String.format("Repo version %s is not available for stack %s",desiredRepoVersion,stackId));
  }
  VersionDefinitionXml desiredVersionDefinition=null;
  try {
    desiredVersionDefinition=repoVersionEnt.getRepositoryXml();
  }
 catch (  Exception e) {
    throw new IllegalArgumentException(String.format("Version %s is backed by a version definition, but it could not be parsed",desiredRepoVersion),e);
  }
  for (  ClusterVersionEntity clusterVersion : clusterVersionDAO.findByCluster(clName)) {
    RepositoryVersionEntity clusterRepoVersion=clusterVersion.getRepositoryVersion();
    int compare=compareVersions(clusterRepoVersion.getVersion(),desiredRepoVersion);
    if (compare <= 0) {
      continue;
    }
    if (!StringUtils.equals(clusterRepoVersion.getStackName(),repoVersionEnt.getStackName())) {
      continue;
    }
    if (null == desiredVersionDefinition) {
      continue;
    }
    for (    Host host : hosts) {
      if (StringUtils.isBlank(desiredVersionDefinition.getPackageVersion(host.getOsFamily()))) {
        String msg=String.format("Ambari cannot install version %s.  Version %s is already installed.",desiredRepoVersion,clusterRepoVersion.getVersion());
        throw new IllegalArgumentException(msg);
      }
    }
  }
  List<OperatingSystemEntity> operatingSystems=repoVersionEnt.getOperatingSystems();
  Map<String,List<RepositoryEntity>> perOsRepos=new HashMap<String,List<RepositoryEntity>>();
  for (  OperatingSystemEntity operatingSystem : operatingSystems) {
    if (operatingSystem.isAmbariManagedRepos()) {
      perOsRepos.put(operatingSystem.getOsType(),operatingSystem.getRepositories());
    }
 else {
      perOsRepos.put(operatingSystem.getOsType(),Collections.<RepositoryEntity>emptyList());
    }
  }
  RequestStageContainer req=createRequest();
  Iterator<Host> hostIterator=hosts.iterator();
  Map<String,String> hostLevelParams=new HashMap<String,String>();
  hostLevelParams.put(JDK_LOCATION,getManagementController().getJdkResourceUrl());
  String hostParamsJson=StageUtils.getGson().toJson(hostLevelParams);
  String clusterHostInfoJson;
  try {
    clusterHostInfoJson=StageUtils.getGson().toJson(StageUtils.getClusterHostInfo(cluster));
  }
 catch (  AmbariException e) {
    throw new SystemException("Could not build cluster topology",e);
  }
  int maxTasks=configuration.getAgentPackageParallelCommandsLimit();
  int hostCount=hosts.size();
  int batchCount=(int)(Math.ceil((double)hostCount / maxTasks));
  ArrayList<Host> directTransitions=new ArrayList<Host>();
  long stageId=req.getLastStageId() + 1;
  if (0L == stageId) {
    stageId=1L;
  }
  boolean hasStage=false;
  ArrayList<Stage> stages=new ArrayList<Stage>(batchCount);
  for (int batchId=1; batchId <= batchCount; batchId++) {
    String stageName;
    if (batchCount > 1) {
      stageName=String.format(INSTALL_PACKAGES_FULL_NAME + ". Batch %d of %d",batchId,batchCount);
    }
 else {
      stageName=INSTALL_PACKAGES_FULL_NAME;
    }
    Stage stage=stageFactory.createNew(req.getId(),"/tmp/ambari",cluster.getClusterName(),cluster.getClusterId(),stageName,clusterHostInfoJson,"{}",hostParamsJson);
    stage.getSuccessFactors().put(Role.INSTALL_PACKAGES,successFactor);
    stage.setStageId(stageId);
    stageId++;
    stages.add(stage);
    Set<String> serviceNames=new HashSet<>();
    for (int i=0; i < maxTasks && hostIterator.hasNext(); i++) {
      Host host=hostIterator.next();
      if (hostHasVersionableComponents(cluster,serviceNames,ami,stackId,host)) {
        ActionExecutionContext actionContext=getHostVersionInstallCommand(repoVersionEnt,cluster,managementController,ami,stackId,serviceNames,perOsRepos,stage,host);
        if (null != actionContext) {
          try {
            actionExecutionHelper.get().addExecutionCommandsToStage(actionContext,stage,null);
            hasStage=true;
          }
 catch (          AmbariException e) {
            throw new SystemException("Cannot modify stage",e);
          }
        }
      }
 else {
        directTransitions.add(host);
      }
    }
  }
  if (!hasStage) {
    throw new SystemException(String.format("There are no hosts that have components to install repository %s",desiredRepoVersion));
  }
  req.addStages(stages);
  try {
    ClusterVersionEntity clusterVersionEntity=clusterVersionDAO.findByClusterAndStackAndVersion(clName,stackId,desiredRepoVersion);
    if (clusterVersionEntity == null) {
      try {
        cluster.createClusterVersion(stackId,desiredRepoVersion,managementController.getAuthName(),RepositoryVersionState.INSTALLING);
        clusterVersionEntity=clusterVersionDAO.findByClusterAndStackAndVersion(clName,stackId,desiredRepoVersion);
      }
 catch (      AmbariException e) {
        throw new SystemException(String.format("Can not create cluster stack version %s for cluster %s",desiredRepoVersion,clName),e);
      }
    }
 else {
      cluster.transitionClusterVersion(stackId,desiredRepoVersion,RepositoryVersionState.INSTALLING);
    }
    cluster.transitionHostsToInstalling(clusterVersionEntity);
    for (    Host host : directTransitions) {
      transitionHostVersionToNotRequired(host,cluster,clusterVersionEntity.getRepositoryVersion());
    }
    req.persist();
  }
 catch (  AmbariException e) {
    throw new SystemException("Can not persist request",e);
  }
  return getRequestStatus(req.getRequestStatusResponse());
}
