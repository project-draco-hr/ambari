def process_portion_of_actions(self, portion):
    running_list = []
    finished_list = []
    while (portion or running_list):
        for thread in running_list:
            if (not thread.is_alive()):
                finished_list.append(thread)
        running_list[:] = [b for b in running_list if (not (b in finished_list))]
        free_slots = (self.MAX_CONCURRENT_ACTIONS - len(running_list))
        while ((free_slots > 0) and portion):
            command = portion.pop()
            logger.debug(('Took an element of Queue: ' + pprint.pformat(command)))
            if (command['commandType'] == self.EXECUTION_COMMAND):
                action_thread = Thread(target=self.execute_command_safely, args=(command,))
                running_list.append(action_thread)
                free_slots -= 1
                action_thread.start()
            elif (command['commandType'] == self.STATUS_COMMAND):
                self.execute_status_command(command)
            else:
                logger.error(('Unrecognized command ' + pprint.pformat(command)))
    pass
