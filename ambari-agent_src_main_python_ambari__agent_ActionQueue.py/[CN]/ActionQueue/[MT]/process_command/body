def process_command(self, command):
    commandType = command['commandType']
    logger.debug(('Took an element of Queue (command type = %s).' % commandType))
    try:
        if (commandType in [self.EXECUTION_COMMAND, self.BACKGROUND_EXECUTION_COMMAND, self.AUTO_EXECUTION_COMMAND]):
            try:
                if self.controller.recovery_manager.enabled():
                    self.controller.recovery_manager.start_execution_command()
                self.execute_command(command)
            finally:
                if self.controller.recovery_manager.enabled():
                    self.controller.recovery_manager.stop_execution_command()
        elif (commandType == self.STATUS_COMMAND):
            component_name = command['componentName']
            if ((component_name in self.hangingStatusCommands) and (not self.hangingStatusCommands[component_name].isAlive())):
                del self.hangingStatusCommands[component_name]
            if (not (component_name in self.hangingStatusCommands)):
                thread = threading.Thread(target=self.execute_status_command, args=(command,))
                thread.daemon = True
                thread.start()
                thread.join(timeout=self.status_command_timeout)
                if thread.isAlive():
                    PythonReflectiveExecutor.last_context.revert()
                    logger.warn('Command {0} for {1} is running for more than {2} seconds. Skipping it for current pack of status commands.'.format(commandType, component_name, self.status_command_timeout))
                    self.hangingStatusCommands[component_name] = thread
            else:
                logger.info('Not running {0} for {1}, because previous one is still running.'.format(commandType, component_name))
        else:
            logger.error(('Unrecognized command ' + pprint.pformat(command)))
    except Exception:
        logger.exception('Exception while processing {0} command'.format(commandType))
