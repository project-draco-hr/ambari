{
  JobKey jobKey=context.getJobDetail().getKey();
  LOG.debug("Executing linear job: " + jobKey);
  if (!executionScheduleManager.continueOnMisfire(context)) {
    throw new JobExecutionException("Canceled execution based on misfire" + " toleration threshold, job: " + jobKey + ", scheduleTime = "+ context.getScheduledFireTime());
  }
  Map<String,Object> properties=context.getMergedJobDataMap().getWrappedMap();
  try {
    doWork(properties);
  }
 catch (  AmbariException e) {
    LOG.error("Exception caught on execution of job " + jobKey + ". Exiting linear chain...",e);
    throw new JobExecutionException(e);
  }
catch (  RuntimeException e) {
    LOG.error("Unexpected exception caught on execution of job " + jobKey + ". "+ "Exiting linear chain...",e);
    throw e;
  }
  LOG.debug("Finished linear job: " + jobKey);
  JobDataMap jobDataMap=context.getMergedJobDataMap();
  String nextJobName=jobDataMap.getString(NEXT_EXECUTION_JOB_NAME_KEY);
  String nextJobGroup=jobDataMap.getString(NEXT_EXECUTION_JOB_GROUP_KEY);
  if (nextJobName == null || nextJobName.isEmpty()) {
    LOG.debug("End of linear job chain. Returning with success.");
    try {
      finalizeExecution(properties);
    }
 catch (    AmbariException e) {
      LOG.warn("Unable to finalize execution for job: " + jobKey);
    }
    return;
  }
  int separationSeconds=jobDataMap.getIntValue(NEXT_EXECUTION_SEPARATION_SECONDS);
  Trigger trigger=newTrigger().forJob(nextJobName,nextJobGroup).withIdentity("TriggerForJob-" + nextJobName,LINEAR_EXECUTION_TRIGGER_GROUP).withSchedule(simpleSchedule().withMisfireHandlingInstructionFireNow()).startAt(futureDate(separationSeconds,DateBuilder.IntervalUnit.SECOND)).build();
  executionScheduleManager.scheduleJob(trigger);
}
