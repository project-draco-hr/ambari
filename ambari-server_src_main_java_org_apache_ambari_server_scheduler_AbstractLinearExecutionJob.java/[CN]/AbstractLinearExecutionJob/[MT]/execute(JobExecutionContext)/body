{
  JobKey jobKey=context.getJobDetail().getKey();
  LOG.debug("Executing linear job: " + jobKey);
  if (!executionScheduleManager.continueOnMisfire(context)) {
    throw new JobExecutionException("Canceled execution based on misfire" + " toleration threshold, job: " + jobKey + ", scheduleTime = "+ context.getScheduledFireTime());
  }
  try {
    doWork(context.getMergedJobDataMap().getWrappedMap());
  }
 catch (  AmbariException e) {
    LOG.error("Exception caught on job execution. Exiting linear chain...",e);
    throw new JobExecutionException(e);
  }
  LOG.debug("Finished linear job: " + jobKey);
  JobDataMap jobDataMap=context.getMergedJobDataMap();
  String nextJobName=jobDataMap.getString(NEXT_EXECUTION_JOB_NAME_KEY);
  String nextJobGroup=jobDataMap.getString(NEXT_EXECUTION_JOB_GROUP_KEY);
  if (nextJobName == null || nextJobName.isEmpty()) {
    LOG.debug("End of linear job chain. Returning with success.");
    return;
  }
  int separationSeconds=jobDataMap.getIntValue((NEXT_EXECUTION_SEPARATION_SECONDS));
  Trigger trigger=newTrigger().forJob(nextJobName,nextJobGroup).withIdentity("TriggerForJob-" + nextJobName,LINEAR_EXECUTION_TRIGGER_GROUP).withSchedule(simpleSchedule().withMisfireHandlingInstructionFireNow()).startAt(futureDate(separationSeconds,DateBuilder.IntervalUnit.SECOND)).build();
  executionScheduleManager.scheduleJob(trigger);
}
