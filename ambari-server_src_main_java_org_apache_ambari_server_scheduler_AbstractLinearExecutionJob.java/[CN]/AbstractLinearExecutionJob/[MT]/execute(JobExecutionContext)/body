{
  JobKey jobKey=context.getJobDetail().getKey();
  LOG.debug("Executing linear job: " + jobKey);
  if (!executionScheduleManager.continueOnMisfire(context)) {
    throw new JobExecutionException("Canceled execution based on misfire" + " toleration threshold, job: " + jobKey + ", scheduleTime = "+ context.getScheduledFireTime());
  }
  try {
    doWork();
  }
 catch (  AmbariException e) {
    LOG.error("Exception caught on job execution. Exiting linear chain...",e);
    throw new JobExecutionException(e);
  }
  JobDataMap jobDataMap=context.getMergedJobDataMap();
  String nextJobName=jobDataMap.getString(NEXT_EXECUTION_JOB_NAME_KEY);
  String nextJobGroup=jobDataMap.getString(NEXT_EXECUTION_JOB_GROUP_KEY);
  Integer separationMinutes=jobDataMap.getIntegerFromString((NEXT_EXECUTION_SEPARATION_MINUTES));
  if (separationMinutes == null) {
    separationMinutes=0;
  }
  Trigger trigger=newTrigger().forJob(nextJobName,nextJobGroup).withIdentity("TriggerForJob-" + nextJobName,LINEAR_EXECUTION_TRIGGER_GROUP).withSchedule(simpleSchedule().withMisfireHandlingInstructionFireNow()).startAt(futureDate(separationMinutes,DateBuilder.IntervalUnit.MINUTE)).build();
  executionScheduleManager.scheduleJob(trigger);
}
