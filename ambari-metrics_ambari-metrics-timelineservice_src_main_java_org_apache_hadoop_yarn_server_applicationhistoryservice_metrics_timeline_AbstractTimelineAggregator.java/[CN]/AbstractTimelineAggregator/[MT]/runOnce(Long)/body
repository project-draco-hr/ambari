{
  long currentTime=clock.getTime();
  long lastCheckPointTime=readLastCheckpointSavingOnFirstRun(currentTime);
  long sleepTime=SLEEP_INTERVAL;
  if (lastCheckPointTime != -1) {
    LOG.info("Last check point time: " + lastCheckPointTime + ", lagBy: "+ ((clock.getTime() - lastCheckPointTime) / 1000)+ " seconds.");
    long startTime=clock.getTime();
    boolean success=doWork(lastCheckPointTime,lastCheckPointTime + SLEEP_INTERVAL);
    long executionTime=clock.getTime() - startTime;
    long delta=SLEEP_INTERVAL - executionTime;
    if (delta > 0) {
      sleepTime=delta;
    }
 else {
      LOG.info("Aggregator execution took too long, " + "cancelling sleep. executionTime = " + executionTime);
      sleepTime=1;
    }
    LOG.debug("Aggregator sleep interval = " + sleepTime);
    if (success) {
      try {
        saveCheckPoint(Math.min(currentTime,lastCheckPointTime + SLEEP_INTERVAL));
      }
 catch (      IOException io) {
        LOG.warn("Error saving checkpoint, restarting aggregation at " + "previous checkpoint.");
      }
    }
  }
  return sleepTime;
}
