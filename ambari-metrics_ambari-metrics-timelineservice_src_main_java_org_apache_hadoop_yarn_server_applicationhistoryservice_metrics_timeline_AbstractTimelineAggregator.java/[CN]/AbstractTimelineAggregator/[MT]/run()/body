{
  LOG.info("Started Timeline aggregator thread @ " + new Date());
  Long SLEEP_INTERVAL=getSleepIntervalMillis();
  while (true) {
    long currentTime=System.currentTimeMillis();
    long lastCheckPointTime=-1;
    try {
      lastCheckPointTime=readCheckPoint();
      if (isLastCheckPointTooOld(lastCheckPointTime)) {
        LOG.warn("Last Checkpoint is too old, discarding last checkpoint. " + "lastCheckPointTime = " + lastCheckPointTime);
        lastCheckPointTime=-1;
      }
      if (lastCheckPointTime == -1) {
        saveCheckPoint(currentTime - checkpointDelayMillis);
      }
    }
 catch (    IOException io) {
      LOG.warn("Unable to write last checkpoint time. Resuming sleep.",io);
    }
    long sleepTime=SLEEP_INTERVAL;
    if (lastCheckPointTime != -1) {
      LOG.info("Last check point time: " + lastCheckPointTime + ", lagBy: "+ ((System.currentTimeMillis() - lastCheckPointTime) / 1000)+ " seconds.");
      long startTime=System.currentTimeMillis();
      boolean success=doWork(lastCheckPointTime,lastCheckPointTime + SLEEP_INTERVAL);
      long executionTime=System.currentTimeMillis() - startTime;
      long delta=SLEEP_INTERVAL - executionTime;
      if (delta > 0) {
        sleepTime=delta;
      }
 else {
        LOG.info("Aggregator execution took too long, " + "cancelling sleep. executionTime = " + executionTime);
        sleepTime=1;
      }
      LOG.debug("Aggregator sleep interval = " + sleepTime);
      if (success) {
        try {
          saveCheckPoint(lastCheckPointTime + SLEEP_INTERVAL);
        }
 catch (        IOException io) {
          LOG.warn("Error saving checkpoint, restarting aggregation at " + "previous checkpoint.");
        }
      }
    }
    try {
      Thread.sleep(sleepTime);
    }
 catch (    InterruptedException e) {
      LOG.info("Sleep interrupted, continuing with aggregation.");
    }
  }
}
