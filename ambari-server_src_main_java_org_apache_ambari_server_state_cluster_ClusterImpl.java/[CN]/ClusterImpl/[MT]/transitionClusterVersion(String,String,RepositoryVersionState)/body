{
  Set<RepositoryVersionState> allowedStates=new HashSet<RepositoryVersionState>();
  clusterGlobalLock.readLock().lock();
  try {
    readWriteLock.writeLock().lock();
    try {
      ClusterVersionEntity existingClusterVersion=clusterVersionDAO.findByClusterAndStackAndVersion(this.getClusterName(),stack,version);
      if (existingClusterVersion == null) {
        throw new AmbariException("Existing cluster version not found for cluster=" + this.getClusterName() + ", stack="+ stack+ ", version="+ version);
      }
      if (existingClusterVersion.getState() != state) {
switch (existingClusterVersion.getState()) {
case CURRENT:
          break;
case INSTALLING:
        allowedStates.add(RepositoryVersionState.INSTALLED);
      allowedStates.add(RepositoryVersionState.INSTALL_FAILED);
    allowedStates.add(RepositoryVersionState.OUT_OF_SYNC);
  break;
case INSTALL_FAILED:
allowedStates.add(RepositoryVersionState.INSTALLING);
break;
case INSTALLED:
allowedStates.add(RepositoryVersionState.INSTALLING);
allowedStates.add(RepositoryVersionState.UPGRADING);
allowedStates.add(RepositoryVersionState.UPGRADED);
allowedStates.add(RepositoryVersionState.OUT_OF_SYNC);
break;
case OUT_OF_SYNC:
allowedStates.add(RepositoryVersionState.INSTALLING);
break;
case UPGRADING:
allowedStates.add(RepositoryVersionState.UPGRADED);
allowedStates.add(RepositoryVersionState.UPGRADE_FAILED);
if (clusterVersionDAO.findByClusterAndStateCurrent(getClusterName()) == null) {
allowedStates.add(RepositoryVersionState.CURRENT);
}
break;
case UPGRADED:
allowedStates.add(RepositoryVersionState.CURRENT);
break;
case UPGRADE_FAILED:
allowedStates.add(RepositoryVersionState.UPGRADING);
break;
}
if (!allowedStates.contains(state)) {
throw new AmbariException("Invalid cluster version transition from " + existingClusterVersion.getState() + " to "+ state);
}
if (state == RepositoryVersionState.CURRENT) {
ClusterVersionEntity currentVersion=clusterVersionDAO.findByClusterAndStateCurrent(this.getClusterName());
if (currentVersion != null) {
currentVersion.setState(RepositoryVersionState.INSTALLED);
clusterVersionDAO.merge(currentVersion);
}
}
existingClusterVersion.setState(state);
existingClusterVersion.setEndTime(System.currentTimeMillis());
clusterVersionDAO.merge(existingClusterVersion);
}
}
 catch (RollbackException e) {
String message="Unable to transition stack " + stack + " at version "+ version+ " for cluster "+ getClusterName()+ " to state "+ state;
LOG.warn(message);
throw new AmbariException(message,e);
}
 finally {
readWriteLock.writeLock().unlock();
}
}
  finally {
clusterGlobalLock.readLock().unlock();
}
}
