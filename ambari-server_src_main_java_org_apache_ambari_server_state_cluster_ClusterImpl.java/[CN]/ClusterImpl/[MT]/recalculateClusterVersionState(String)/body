{
  if (repositoryVersion == null) {
    return;
  }
  clusterGlobalLock.readLock().lock();
  try {
    readWriteLock.writeLock().lock();
    try {
      StackId stackId=getCurrentStackVersion();
      ClusterVersionEntity clusterVersion=clusterVersionDAO.findByClusterAndStackAndVersion(this.getClusterName(),stackId.getStackId(),repositoryVersion);
      if (clusterVersion == null) {
        if (clusterVersionDAO.findByCluster(getClusterName()).isEmpty()) {
          createClusterVersionInternal(stackId.getStackId(),repositoryVersion,AuthorizationHelper.getAuthenticatedName(configuration.getAnonymousAuditName()),RepositoryVersionState.UPGRADING);
          clusterVersion=clusterVersionDAO.findByClusterAndStackAndVersion(this.getClusterName(),stackId.getStackId(),repositoryVersion);
        }
 else {
          throw new AmbariException(String.format("Repository version %s not found for cluster %s",repositoryVersion,getClusterName()));
        }
      }
      RepositoryVersionState lowestPriorityState;
      if (clusterVersion.getState() != RepositoryVersionState.INSTALL_FAILED && clusterVersion.getState() != RepositoryVersionState.OUT_OF_SYNC && clusterVersion.getState() != RepositoryVersionState.INSTALLING && clusterVersion.getState() != RepositoryVersionState.INSTALLED && clusterVersion.getState() != RepositoryVersionState.UPGRADING && clusterVersion.getState() != RepositoryVersionState.UPGRADED) {
        return;
      }
      Map<String,Host> hosts=clusters.getHostsForCluster(this.getClusterName());
      Map<RepositoryVersionState,Set<String>> stateToHosts=new HashMap<RepositoryVersionState,Set<String>>();
      for (      Host host : hosts.values()) {
        String hostName=host.getHostName();
        HostVersionEntity hostVersion=hostVersionDAO.findByClusterStackVersionAndHost(this.getClusterName(),stackId.getStackId(),repositoryVersion,hostName);
        if (hostVersion == null) {
          LOG.debug("Skipping transitioning the cluster version because host " + hostName + " does not have a version yet.");
          return;
        }
        RepositoryVersionState hostState=hostVersion.getState();
        if (host.getState() != HostState.HEALTHY) {
          hostState=RepositoryVersionState.OUT_OF_SYNC;
          LOG.warn(String.format("Host %s is in unhealthy state, treating as %s",hostName,hostState));
        }
        if (stateToHosts.containsKey(hostState)) {
          stateToHosts.get(hostState).add(hostName);
        }
 else {
          Set<String> hostsInState=new HashSet<String>();
          hostsInState.add(hostName);
          stateToHosts.put(hostState,hostsInState);
        }
      }
      RepositoryVersionState effectiveClusterVersionState=getEffectiveState(stateToHosts);
      if (effectiveClusterVersionState != null && effectiveClusterVersionState != clusterVersion.getState()) {
        try {
          transitionClusterVersion(stackId.getStackId(),repositoryVersion,effectiveClusterVersionState);
        }
 catch (        AmbariException e) {
          ;
        }
      }
    }
  finally {
      readWriteLock.writeLock().unlock();
    }
  }
  finally {
    clusterGlobalLock.readLock().unlock();
  }
}
