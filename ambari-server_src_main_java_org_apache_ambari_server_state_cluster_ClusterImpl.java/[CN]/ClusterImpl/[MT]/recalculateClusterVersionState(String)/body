{
  clusterGlobalLock.readLock().lock();
  try {
    readWriteLock.writeLock().lock();
    try {
      Map<String,Host> hosts=clusters.getHostsForCluster(this.getClusterName());
      String stackId=this.getCurrentStackVersion().getStackId();
      ClusterVersionEntity clusterVersion=clusterVersionDAO.findByClusterAndStackAndVersion(this.getClusterName(),stackId,repositoryVersion);
      if (clusterVersion == null) {
        throw new AmbariException(String.format("Repository version %s not found for cluster %s",repositoryVersion,getClusterName()));
      }
      RepositoryVersionState worstState;
      if (clusterVersion.getState() != RepositoryVersionState.INSTALL_FAILED && clusterVersion.getState() != RepositoryVersionState.OUT_OF_SYNC && clusterVersion.getState() != RepositoryVersionState.INSTALLING && clusterVersion.getState() != RepositoryVersionState.INSTALLED && clusterVersion.getState() != RepositoryVersionState.UPGRADING && clusterVersion.getState() != RepositoryVersionState.UPGRADED) {
        return;
      }
      worstState=RepositoryVersionState.UPGRADED;
      for (      Host host : hosts.values()) {
        String hostName=host.getHostName();
        if (host.getState() != HostState.HEALTHY) {
          worstState=getWorstState(worstState,RepositoryVersionState.OUT_OF_SYNC);
          LOG.warn(String.format("Host %s is in unhealthy state, treating as %s",hostName,worstState));
        }
        HostVersionEntity hostVersion=hostVersionDAO.findByClusterStackVersionAndHost(this.getClusterName(),stackId,repositoryVersion,hostName);
        if (hostVersion == null) {
          LOG.warn(String.format("Repo version %s is not installed on host %s",repositoryVersion,hostName));
          worstState=getWorstState(worstState,RepositoryVersionState.OUT_OF_SYNC);
        }
 else {
          worstState=getWorstState(worstState,hostVersion.getState());
        }
      }
      if (worstState != clusterVersion.getState()) {
        transitionClusterVersion(stackId,repositoryVersion,worstState);
      }
      clusterVersionDAO.merge(clusterVersion);
    }
  finally {
      readWriteLock.writeLock().unlock();
    }
  }
  finally {
    clusterGlobalLock.readLock().unlock();
  }
}
