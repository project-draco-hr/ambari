{
  if (sourceClusterVersion == null) {
    throw new AmbariException("Could not find current stack version of cluster " + this.getClusterName());
  }
  RepositoryVersionState desiredState=sourceClusterVersion.getState();
  Set<RepositoryVersionState> validStates=new HashSet<RepositoryVersionState>(){
{
      add(RepositoryVersionState.INSTALLING);
    }
  }
;
  if (!validStates.contains(desiredState)) {
    throw new AmbariException("The state must be one of " + validStates);
  }
  clusterGlobalLock.readLock().lock();
  try {
    readWriteLock.writeLock().lock();
    try {
      Set<String> existingHostsWithClusterStackAndVersion=new HashSet<String>();
      HashMap<String,HostVersionEntity> existingHostStackVersions=new HashMap<String,HostVersionEntity>();
      List<HostVersionEntity> existingHostVersionEntities=hostVersionDAO.findByClusterStackAndVersion(this.getClusterName(),sourceClusterVersion.getStack(),sourceClusterVersion.getVersion());
      if (existingHostVersionEntities != null) {
        for (        HostVersionEntity entity : existingHostVersionEntities) {
          existingHostsWithClusterStackAndVersion.add(entity.getHostName());
          existingHostStackVersions.put(entity.getHostName(),entity);
        }
      }
      Map<String,Host> hosts=clusters.getHostsForCluster(this.getClusterName());
      Sets.SetView<String> hostsMissingRepoVersion=Sets.difference(hosts.keySet(),existingHostsWithClusterStackAndVersion);
      for (      String hostname : hosts.keySet()) {
        if (hostsMissingRepoVersion.contains(hostname)) {
          HostEntity hostEntity=hostDAO.findByName(hostname);
          HostVersionEntity hostVersionEntity=new HostVersionEntity(hostname,sourceClusterVersion.getStack(),sourceClusterVersion.getVersion(),RepositoryVersionState.INSTALLING);
          hostVersionEntity.setHostEntity(hostEntity);
          hostVersionDAO.create(hostVersionEntity);
        }
 else {
          HostVersionEntity hostVersionEntity=existingHostStackVersions.get(hostname);
          hostVersionEntity.setState(desiredState);
          hostVersionDAO.merge(hostVersionEntity);
        }
      }
    }
  finally {
      readWriteLock.writeLock().unlock();
    }
  }
  finally {
    clusterGlobalLock.readLock().unlock();
  }
}
