def runPuppetFile(self, puppetFile, result, puppetEnv, tmpoutfile, tmperrfile):
    ' Run the command and make sure the output gets propagated'
    puppetcommand = self.puppetCommand(puppetFile)
    rubyLib = ''
    if os.environ.has_key('RUBYLIB'):
        rubyLib = os.environ['RUBYLIB']
        logger.debug(('RUBYLIB from Env ' + rubyLib))
    if (not (self.facterLib() in rubyLib)):
        rubyLib = ((rubyLib + ':') + self.facterLib())
    if (not (self.puppetLib() in rubyLib)):
        rubyLib = ((rubyLib + ':') + self.puppetLib())
    tmpout = open(tmpoutfile, 'w')
    tmperr = open(tmperrfile, 'w')
    puppetEnv['RUBYLIB'] = rubyLib
    puppetEnv = self.configureEnviron(puppetEnv)
    logger.debug(('Setting RUBYLIB as: ' + rubyLib))
    logger.info(('Running command ' + pprint.pformat(puppetcommand)))
    puppet = self.lauch_puppet_subprocess(puppetcommand, tmpout, tmperr, puppetEnv)
    logger.info(('Command started with PID: ' + str(puppet.pid)))
    logger.debug('Launching watchdog thread')
    self.event.clear()
    self.last_puppet_has_been_killed = False
    thread = Thread(target=self.puppet_watchdog_func, args=(puppet,))
    thread.start()
    puppet.communicate()
    self.event.set()
    thread.join()
    error = self.NO_ERROR
    returncode = 0
    if (not self.isSuccessfull(puppet.returncode)):
        returncode = puppet.returncode
        error = open(tmperrfile, 'r').read()
        logging.error(('Error running puppet: \n' + str(error)))
        pass
    if self.last_puppet_has_been_killed:
        error = (str(error) + '\n Puppet has been killed due to timeout')
        returncode = 999
    if result.has_key('stderr'):
        result['stderr'] = ((result['stderr'] + os.linesep) + str(error))
    else:
        result['stderr'] = str(error)
    puppetOutput = open(tmpoutfile, 'r').read()
    logger.debug(('Output from puppet :\n' + puppetOutput))
    logger.info(('Puppet execution process with pid %s exited with code %s.' % (str(puppet.pid), str(returncode))))
    if result.has_key('exitcode'):
        result['exitcode'] = max(returncode, result['exitcode'])
    else:
        result['exitcode'] = returncode
    condensed = self.condenseOutput(puppetOutput, error, returncode)
    if result.has_key('stdout'):
        result['stdout'] = ((result['stdout'] + os.linesep) + str(condensed))
    else:
        result['stdout'] = str(condensed)
    return result
