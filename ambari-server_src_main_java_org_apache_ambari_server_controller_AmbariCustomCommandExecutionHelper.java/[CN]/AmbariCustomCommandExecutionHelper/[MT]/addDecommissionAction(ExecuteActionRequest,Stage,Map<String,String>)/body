{
  String clusterName=request.getClusterName();
  Cluster cluster=clusters.getCluster(clusterName);
  String serviceName=request.getServiceName();
  if (request.getHosts() != null && request.getHosts().size() != 0) {
    throw new AmbariException("Decommission command cannot be issued with target host(s) specified.");
  }
  Set<String> excludedHosts=getHostList(request.getParameters(),DECOM_EXCLUDED_HOSTS);
  Set<String> includedHosts=getHostList(request.getParameters(),DECOM_INCLUDED_HOSTS);
  String slaveCompType=request.getParameters().get(DECOM_SLAVE_COMPONENT);
  Set<String> cloneSet=new HashSet<String>(excludedHosts);
  cloneSet.retainAll(includedHosts);
  if (cloneSet.size() > 0) {
    throw new AmbariException("Same host cannot be specified for inclusion as well as exclusion. Hosts: " + cloneSet.toString());
  }
  Service service=cluster.getService(serviceName);
  if (service == null) {
    throw new AmbariException("Specified service " + serviceName + " is not a valid/deployed service.");
  }
  String masterCompType=request.getComponentName();
  Map<String,ServiceComponent> svcComponents=service.getServiceComponents();
  if (!svcComponents.containsKey(masterCompType)) {
    throw new AmbariException("Specified component " + masterCompType + " does not belong to service "+ serviceName+ ".");
  }
  ServiceComponent masterComponent=svcComponents.get(masterCompType);
  if (!masterComponent.isMasterComponent()) {
    throw new AmbariException("Specified component " + masterCompType + " is not a MASTER for service "+ serviceName+ ".");
  }
  if (!masterToSlaveMappingForDecom.containsKey(masterCompType)) {
    throw new AmbariException("Decommissioning is not supported for " + masterCompType);
  }
  if (slaveCompType == null || slaveCompType.equals("")) {
    slaveCompType=masterToSlaveMappingForDecom.get(masterCompType);
  }
 else   if (!masterToSlaveMappingForDecom.get(masterCompType).equals(slaveCompType)) {
    throw new AmbariException("Component " + slaveCompType + " is not supported for decommissioning.");
  }
  String isDrainOnlyRequest=request.getParameters().get(HBASE_MARK_DRAINING_ONLY);
  if (isDrainOnlyRequest != null && !slaveCompType.equals(Role.HBASE_REGIONSERVER.name())) {
    throw new AmbariException(HBASE_MARK_DRAINING_ONLY + " is not a valid parameter for " + masterCompType);
  }
  for (  ServiceComponentHost sch : svcComponents.get(slaveCompType).getServiceComponentHosts().values()) {
    if (excludedHosts.contains(sch.getHostName()) && !"true".equals(isDrainOnlyRequest) && sch.getState() != State.STARTED) {
      throw new AmbariException("Component " + slaveCompType + " on host "+ sch.getHostName()+ " cannot be "+ "decommissioned as its not in STARTED state. Aborting the whole request.");
    }
  }
  List<String> listOfExcludedHosts=new ArrayList<String>();
  for (  ServiceComponentHost sch : svcComponents.get(slaveCompType).getServiceComponentHosts().values()) {
    if (excludedHosts.contains(sch.getHostName())) {
      sch.setComponentAdminState(HostComponentAdminState.DECOMMISSIONED);
      listOfExcludedHosts.add(sch.getHostName());
      sch.setPassiveState(PassiveState.PASSIVE);
      LOG.info("Decommissioning " + slaveCompType + " and marking it PASSIVE on "+ sch.getHostName());
    }
    if (includedHosts.contains(sch.getHostName())) {
      sch.setComponentAdminState(HostComponentAdminState.INSERVICE);
      sch.setPassiveState(PassiveState.ACTIVE);
      LOG.info("Recommissioning " + slaveCompType + " and marking it ACTIVE on "+ sch.getHostName());
    }
  }
  Set<String> masterHosts=masterComponent.getServiceComponentHosts().keySet();
  ExecuteActionRequest commandRequest=new ExecuteActionRequest(request.getClusterName(),request.getCommandName(),request.getActionName(),request.getServiceName(),masterComponent.getName(),new ArrayList<String>(masterHosts),null);
  String clusterHostInfoJson=StageUtils.getGson().toJson(StageUtils.getClusterHostInfo(clusters.getHostsForCluster(cluster.getClusterName()),cluster));
  stage.setClusterHostInfo(clusterHostInfoJson);
  Map<String,String> commandParams=null;
  if (serviceName.equals(Service.Type.HBASE.name()) && listOfExcludedHosts.size() > 0) {
    commandParams=new HashMap<String,String>();
    commandParams.put(DECOM_EXCLUDED_HOSTS,StringUtils.join(listOfExcludedHosts,','));
    if (isDrainOnlyRequest != null) {
      if (isDrainOnlyRequest.equals("true") || isDrainOnlyRequest.equals("false")) {
        commandParams.put(HBASE_MARK_DRAINING_ONLY,isDrainOnlyRequest);
      }
    }
  }
  addCustomCommandAction(commandRequest,stage,hostLevelParams,commandParams);
}
