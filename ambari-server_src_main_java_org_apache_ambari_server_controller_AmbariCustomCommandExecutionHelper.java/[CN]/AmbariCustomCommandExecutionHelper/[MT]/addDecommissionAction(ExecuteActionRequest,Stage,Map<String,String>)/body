{
  String clusterName=request.getClusterName();
  Cluster cluster=clusters.getCluster(clusterName);
  String serviceName=request.getServiceName();
  if (request.getHosts() != null && request.getHosts().size() != 0) {
    throw new AmbariException("Decommission command cannot be issued with target host(s) specified.");
  }
  Set<String> excludedHosts=getHostList(request.getParameters(),DECOM_EXCLUDED_HOSTS);
  Set<String> includedHosts=getHostList(request.getParameters(),DECOM_INCLUDED_HOSTS);
  String slaveCompType=request.getParameters().get(DECOM_SLAVE_COMPONENT);
  Set<String> cloneSet=new HashSet<String>(excludedHosts);
  cloneSet.retainAll(includedHosts);
  if (cloneSet.size() > 0) {
    throw new AmbariException("Same host cannot be specified for inclusion as well as exclusion. Hosts: " + cloneSet.toString());
  }
  Service service=cluster.getService(serviceName);
  if (service == null) {
    throw new AmbariException("Specified service " + serviceName + " is not a valid/deployed service.");
  }
  String masterCompType=request.getComponentName();
  Map<String,ServiceComponent> svcComponents=service.getServiceComponents();
  if (!svcComponents.containsKey(masterCompType)) {
    throw new AmbariException("Specified component " + masterCompType + " does not belong to service "+ serviceName+ ".");
  }
  ServiceComponent masterComponent=svcComponents.get(masterCompType);
  if (!masterComponent.isMasterComponent()) {
    throw new AmbariException("Specified component " + masterCompType + " is not a MASTER for service "+ serviceName+ ".");
  }
  if (!masterToSlaveMappingForDecom.containsKey(masterCompType)) {
    throw new AmbariException("Decommissioning is not supported for " + masterCompType);
  }
  if (slaveCompType == null || slaveCompType.equals("")) {
    slaveCompType=masterToSlaveMappingForDecom.get(masterCompType);
  }
 else   if (!masterToSlaveMappingForDecom.get(masterCompType).equals(slaveCompType)) {
    throw new AmbariException("Component " + slaveCompType + " is not supported for decommissioning.");
  }
  String isDrainOnlyRequest=request.getParameters().get(HBASE_MARK_DRAINING_ONLY);
  if (isDrainOnlyRequest != null && !slaveCompType.equals(Role.HBASE_REGIONSERVER.name())) {
    throw new AmbariException(HBASE_MARK_DRAINING_ONLY + " is not a valid parameter for " + masterCompType);
  }
  for (  ServiceComponentHost sch : svcComponents.get(slaveCompType).getServiceComponentHosts().values()) {
    if (excludedHosts.contains(sch.getHostName()) && !"true".equals(isDrainOnlyRequest) && sch.getState() != State.STARTED) {
      throw new AmbariException("Component " + slaveCompType + " on host "+ sch.getHostName()+ " cannot be "+ "decommissioned as its not in STARTED state. Aborting the whole request.");
    }
  }
  String alignMtnStateStr=request.getParameters().get(ALIGN_MAINTENANCE_STATE);
  boolean alignMtnState="true".equals(alignMtnStateStr);
  List<String> listOfExcludedHosts=new ArrayList<String>();
  for (  ServiceComponentHost sch : svcComponents.get(slaveCompType).getServiceComponentHosts().values()) {
    if (excludedHosts.contains(sch.getHostName())) {
      sch.setComponentAdminState(HostComponentAdminState.DECOMMISSIONED);
      listOfExcludedHosts.add(sch.getHostName());
      if (alignMtnState) {
        sch.setPassiveState(PassiveState.PASSIVE);
      }
      LOG.info("Decommissioning " + slaveCompType + " and marking it PASSIVE on "+ sch.getHostName());
    }
    if (includedHosts.contains(sch.getHostName())) {
      sch.setComponentAdminState(HostComponentAdminState.INSERVICE);
      if (alignMtnState) {
        sch.setPassiveState(PassiveState.ACTIVE);
      }
      LOG.info("Recommissioning " + slaveCompType + " and marking it ACTIVE on "+ sch.getHostName());
    }
  }
  Map<String,ServiceComponentHost> masterSchs=masterComponent.getServiceComponentHosts();
  String primaryCandidate=null;
  for (  String hostName : masterSchs.keySet()) {
    if (primaryCandidate == null) {
      primaryCandidate=hostName;
    }
 else {
      ServiceComponentHost sch=masterSchs.get(hostName);
      if (sch.getState() == State.STARTED) {
        primaryCandidate=hostName;
      }
    }
  }
  StringBuilder commandDetail=getReadableDecommissionCommandDetail(request,includedHosts,listOfExcludedHosts);
  for (  String hostName : masterSchs.keySet()) {
    ExecuteActionRequest commandRequest=new ExecuteActionRequest(request.getClusterName(),request.getCommandName(),request.getActionName(),request.getServiceName(),masterComponent.getName(),Collections.singletonList(hostName),null);
    String clusterHostInfoJson=StageUtils.getGson().toJson(StageUtils.getClusterHostInfo(clusters.getHostsForCluster(cluster.getClusterName()),cluster));
    stage.setClusterHostInfo(clusterHostInfoJson);
    Map<String,String> commandParams=new HashMap<String,String>();
    if (serviceName.equals(Service.Type.HBASE.name())) {
      commandParams.put(DECOM_EXCLUDED_HOSTS,StringUtils.join(listOfExcludedHosts,','));
      if ((isDrainOnlyRequest != null) && isDrainOnlyRequest.equals("true")) {
        commandParams.put(HBASE_MARK_DRAINING_ONLY,isDrainOnlyRequest);
      }
 else {
        commandParams.put(HBASE_MARK_DRAINING_ONLY,"false");
      }
    }
    if (!serviceName.equals(Service.Type.HBASE.name()) || hostName.equals(primaryCandidate)) {
      commandParams.put(UPDATE_EXCLUDE_FILE_ONLY,"false");
      addCustomCommandAction(commandRequest,stage,hostLevelParams,commandParams,commandDetail.toString());
    }
  }
}
