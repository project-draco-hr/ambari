{
  if (executionCommand != null) {
    return executionCommand;
  }
 else   if (jsonExecutionCommand != null) {
    executionCommand=StageUtils.getGson().fromJson(jsonExecutionCommand,ExecutionCommand.class);
    if (injector == null) {
      throw new RuntimeException("Injector not found, configuration cannot be restored");
    }
 else     if (executionCommand.getConfigurationTags() != null && !executionCommand.getConfigurationTags().isEmpty()) {
      Clusters clusters=injector.getInstance(Clusters.class);
      HostRoleCommandDAO hostRoleCommandDAO=injector.getInstance(HostRoleCommandDAO.class);
      Long clusterId=hostRoleCommandDAO.findByPK(executionCommand.getTaskId()).getStage().getClusterId();
      try {
        Cluster cluster=clusters.getClusterById(clusterId);
        ConfigHelper configHelper=injector.getInstance(ConfigHelper.class);
        Map<String,Map<String,String>> configurationTags=executionCommand.getConfigurationTags();
        Set<String> refreshConfigTagsBeforeExecution=executionCommand.getForceRefreshConfigTagsBeforeExecution();
        if (refreshConfigTagsBeforeExecution != null && !refreshConfigTagsBeforeExecution.isEmpty()) {
          Map<String,DesiredConfig> desiredConfigs=cluster.getDesiredConfigs();
          for (          String refreshConfigTag : refreshConfigTagsBeforeExecution) {
            if ("*".equals(refreshConfigTag)) {
              LOG.debug("ExecutionCommandWrapper.getExecutionCommand: refreshConfigTag set to {}, so clearing config for full refresh.",refreshConfigTag);
              executionCommand.getConfigurations().clear();
              for (              final Entry<String,DesiredConfig> desiredConfig : desiredConfigs.entrySet()) {
                configurationTags.put(desiredConfig.getKey(),new HashMap<String,String>(){
{
                    put("tag",desiredConfig.getValue().getTag());
                  }
                }
);
              }
              break;
            }
 else             if (configurationTags.containsKey(refreshConfigTag) && desiredConfigs.containsKey(refreshConfigTag)) {
              configurationTags.get(refreshConfigTag).put("tag",desiredConfigs.get(refreshConfigTag).getTag());
            }
          }
        }
        Map<String,Map<String,String>> configProperties=configHelper.getEffectiveConfigProperties(cluster,configurationTags);
        for (        Map.Entry<String,Map<String,String>> entry : configProperties.entrySet()) {
          String type=entry.getKey();
          Map<String,String> allLevelMergedConfig=entry.getValue();
          if (executionCommand.getConfigurations().containsKey(type)) {
            Map<String,String> mergedConfig=configHelper.getMergedConfig(allLevelMergedConfig,executionCommand.getConfigurations().get(type));
            executionCommand.getConfigurations().get(type).clear();
            executionCommand.getConfigurations().get(type).putAll(mergedConfig);
          }
 else {
            executionCommand.getConfigurations().put(type,new HashMap<String,String>());
            executionCommand.getConfigurations().get(type).putAll(allLevelMergedConfig);
          }
        }
        Map<String,Map<String,Map<String,String>>> configAttributes=configHelper.getEffectiveConfigAttributes(cluster,executionCommand.getConfigurationTags());
        for (        Map.Entry<String,Map<String,Map<String,String>>> attributesOccurrence : configAttributes.entrySet()) {
          String type=attributesOccurrence.getKey();
          Map<String,Map<String,String>> attributes=attributesOccurrence.getValue();
          if (executionCommand.getConfigurationAttributes() != null) {
            if (!executionCommand.getConfigurationAttributes().containsKey(type)) {
              executionCommand.getConfigurationAttributes().put(type,new TreeMap<String,Map<String,String>>());
            }
            configHelper.cloneAttributesMap(attributes,executionCommand.getConfigurationAttributes().get(type));
          }
        }
      }
 catch (      AmbariException e) {
        throw new RuntimeException(e);
      }
    }
    return executionCommand;
  }
 else {
    throw new RuntimeException("Invalid ExecutionCommandWrapper, both object and string" + " representations are null");
  }
}
