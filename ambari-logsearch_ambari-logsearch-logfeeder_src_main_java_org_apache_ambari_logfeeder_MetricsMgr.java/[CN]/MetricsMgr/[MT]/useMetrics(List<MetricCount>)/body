{
  if (!isMetricsEnabled) {
    return;
  }
  logger.info("useMetrics() metrics.size=" + metricsList.size());
  long currMS=System.currentTimeMillis();
  Long currMSLong=new Long(currMS);
  for (  MetricCount metric : metricsList) {
    if (metric.metricsName == null) {
      logger.debug("metric.metricsName is null");
      continue;
    }
    long currCount=metric.count;
    if (!metric.isPointInTime && metric.publishCount > 0 && currCount <= metric.prevPublishCount) {
      logger.debug("Nothing changed. " + metric.metricsName + ", currCount="+ currCount+ ", prevPublishCount="+ metric.prevPublishCount);
      continue;
    }
    metric.publishCount++;
    TimelineMetric timelineMetric=metricsMap.get(metric.metricsName);
    if (timelineMetric == null) {
      logger.debug("Creating new metric obbject for " + metric.metricsName);
      timelineMetric=new TimelineMetric();
      timelineMetric.setMetricName(metric.metricsName);
      timelineMetric.setHostName(nodeHostName);
      timelineMetric.setAppId(appId);
      timelineMetric.setStartTime(currMS);
      timelineMetric.setType("Long");
      timelineMetric.setMetricValues(new TreeMap<Long,Double>());
      metricsMap.put(metric.metricsName,timelineMetric);
    }
    logger.debug("Adding metrics=" + metric.metricsName);
    if (metric.isPointInTime) {
      timelineMetric.getMetricValues().put(currMSLong,new Double(currCount));
    }
 else {
      Double value=timelineMetric.getMetricValues().get(currMSLong);
      if (value == null) {
        value=new Double(0);
      }
      value+=(currCount - metric.prevPublishCount);
      timelineMetric.getMetricValues().put(currMSLong,value);
      metric.prevPublishCount=currCount;
      metric.prevPublishMS=currMS;
    }
  }
  if (metricsMap.size() > 0 && currMS - lastPublishTimeMS > publishIntervalMS) {
    try {
      TimelineMetrics timelineMetrics=new TimelineMetrics();
      List<TimelineMetric> timeLineMetricList=new ArrayList<TimelineMetric>();
      timeLineMetricList.addAll(metricsMap.values());
      timelineMetrics.setMetrics(timeLineMetricList);
      amsClient.emitMetrics(timelineMetrics);
      logger.info("Published " + timeLineMetricList.size() + " metrics to AMS");
      metricsMap.clear();
      timeLineMetricList.clear();
      lastPublishTimeMS=currMS;
    }
 catch (    Throwable t) {
      logger.warn("Error sending metrics to AMS.",t);
      if (currMS - lastFailedPublishTimeMS > maxMetricsBuffer) {
        logger.error("AMS was not sent for last " + maxMetricsBuffer / 1000 + " seconds. Purging it and will start rebuilding it again");
        metricsMap.clear();
        lastFailedPublishTimeMS=currMS;
      }
    }
  }
 else {
    logger.info("Not publishing metrics. metrics.size()=" + metricsMap.size() + ", lastPublished="+ (currMS - lastPublishTimeMS) / 1000 + " seconds ago, intervalConfigured=" + publishIntervalMS / 1000);
  }
}
