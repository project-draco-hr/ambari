@not_for_platform(PLATFORM_WINDOWS)
@patch.object(OSCheck, 'os_distribution', new=MagicMock(return_value=os_distro_value))
@patch('time.sleep')
@patch('sys.exit')
@patch('os.path.exists')
def test_daemonize_and_stop(self, exists_mock, sys_exit_mock, sleep_mock):
    from ambari_commons.shell import shellRunnerLinux
    oldpid = ProcessHelper.pidfile
    pid = str(os.getpid())
    (_, tmpoutfile) = tempfile.mkstemp()
    ProcessHelper.pidfile = tmpoutfile
    main.daemonize()
    saved = open(ProcessHelper.pidfile, 'r').read()
    self.assertEqual(pid, saved)
    with patch('ambari_commons.shell.shellRunnerLinux.run') as kill_mock:
        exists_mock.return_value = False
        main.stop_agent()
        kill_mock.assert_called_with(['ambari-sudo.sh', 'kill', '-15', pid])
        sys_exit_mock.assert_called_with(0)
        kill_mock.reset_mock()
        sys_exit_mock.reset_mock()
        kill_mock.return_value = {'exitCode': 0, 'output': 'out', 'error': 'err', }
        exists_mock.return_value = True
        main.stop_agent()
        kill_mock.assert_any_call(['ambari-sudo.sh', 'kill', '-15', pid])
        kill_mock.assert_any_call(['ambari-sudo.sh', 'kill', '-9', pid])
        sys_exit_mock.assert_called_with(0)
    ProcessHelper.pidfile = oldpid
    os.remove(tmpoutfile)
