{
  String tableName="serviceconfigmapping";
  String dbType=getDbType();
  EntityManager em=getEntityManagerProvider().get();
  if (dbAccessor.tableExists(tableName) && dbAccessor.tableHasData(tableName) && dbAccessor.tableExists("clusterconfigmapping")) {
    if (dbType.equals(Configuration.POSTGRES_DB_NAME)) {
      dbAccessor.executeQuery(getPostgresServiceConfigMappingQuery());
      dbAccessor.truncateTable(tableName);
    }
 else {
      LOG.warn("Unsupported database for service config mapping query. " + "database = " + dbType);
    }
  }
  if (dbAccessor.tableExists("ambari_sequences")) {
    if (dbType.equals(Configuration.POSTGRES_DB_NAME)) {
      ResultSet resultSet=dbAccessor.executeSelect("select * from ambari_sequences where sequence_name in " + "('cluster_id_seq','user_id_seq','host_role_command_id_seq')");
      try {
        if (!resultSet.next()) {
          dbAccessor.executeQuery(getPostgresSequenceUpgradeQuery(),true);
          dbAccessor.dropSequence("host_role_command_task_id_seq");
          dbAccessor.dropSequence("users_user_id_seq");
          dbAccessor.dropSequence("clusters_cluster_id_seq");
        }
      }
  finally {
        resultSet.close();
      }
    }
  }
  String valueColumnName="sequence_value";
  dbAccessor.executeQuery("INSERT INTO ambari_sequences(sequence_name, " + valueColumnName + ") "+ "VALUES('configgroup_id_seq', 1)",true);
  dbAccessor.executeQuery("INSERT INTO ambari_sequences(sequence_name, " + valueColumnName + ") "+ "VALUES('requestschedule_id_seq', 1)",true);
  dbAccessor.executeQuery("INSERT INTO ambari_sequences(sequence_name, " + valueColumnName + ") "+ "VALUES('resourcefilter_id_seq', 1)",true);
  ((JpaEntityManager)em.getDelegate()).getServerSession().getIdentityMapAccessor().invalidateAll();
  executeInTransaction(new Runnable(){
    @Override public void run(){
      EntityManager em=getEntityManagerProvider().get();
      Query nativeQuery=em.createNativeQuery("UPDATE hostcomponentstate SET current_state=?1 WHERE current_state in (?2, ?3)");
      nativeQuery.setParameter(1,"INSTALLED");
      nativeQuery.setParameter(2,"STOP_FAILED");
      nativeQuery.setParameter(3,"START_FAILED");
      nativeQuery.executeUpdate();
    }
  }
);
  executeInTransaction(new Runnable(){
    @Override public void run(){
      EntityManager em=getEntityManagerProvider().get();
      CriteriaBuilder cb=em.getCriteriaBuilder();
      CriteriaQuery<HostRoleCommandEntity> c2=cb.createQuery(HostRoleCommandEntity.class);
      Root<HostRoleCommandEntity> hrc=c2.from(HostRoleCommandEntity.class);
      List<HostRoleStatus> statuses=new ArrayList<HostRoleStatus>(){
{
          add(HostRoleStatus.PENDING);
          add(HostRoleStatus.QUEUED);
          add(HostRoleStatus.IN_PROGRESS);
        }
      }
;
      Expression<String> exp=hrc.get("status");
      Predicate predicate=exp.in(statuses);
      c2.select(hrc).where(predicate);
      TypedQuery<HostRoleCommandEntity> q2=em.createQuery(c2);
      List<HostRoleCommandEntity> r2=q2.getResultList();
      HostRoleCommandDAO hostRoleCommandDAO=injector.getInstance(HostRoleCommandDAO.class);
      if (r2 != null && !r2.isEmpty()) {
        for (        HostRoleCommandEntity entity : r2) {
          entity.setStatus(HostRoleStatus.ABORTED);
          hostRoleCommandDAO.merge(entity);
        }
      }
    }
  }
);
  stackUpgradeUtil.updateStackDetails("HDP",null);
  executeInTransaction(new Runnable(){
    @Override public void run(){
      ClusterDAO clusterDAO=injector.getInstance(ClusterDAO.class);
      ClusterStateDAO clusterStateDAO=injector.getInstance(ClusterStateDAO.class);
      List<ClusterEntity> clusterEntities=clusterDAO.findAll();
      for (      ClusterEntity clusterEntity : clusterEntities) {
        if (clusterStateDAO.findByPK(clusterEntity.getClusterId()) == null) {
          ClusterStateEntity clusterStateEntity=new ClusterStateEntity();
          clusterStateEntity.setClusterEntity(clusterEntity);
          clusterStateEntity.setCurrentStackVersion(clusterEntity.getDesiredStackVersion());
          clusterStateDAO.create(clusterStateEntity);
          clusterEntity.setClusterStateEntity(clusterStateEntity);
          clusterDAO.merge(clusterEntity);
        }
      }
    }
  }
);
  executeInTransaction(new Runnable(){
    @Override public void run(){
      addHistoryServer();
    }
  }
);
  executeInTransaction(new Runnable(){
    @Override public void run(){
      addMissingLog4jConfigs();
    }
  }
);
  executeInTransaction(new Runnable(){
    @Override public void run(){
      try {
        processDecommissionedDatanodes();
      }
 catch (      Exception e) {
        LOG.warn("Updating decommissioned datanodes to new format threw " + "exception. ",e);
      }
    }
  }
);
}
