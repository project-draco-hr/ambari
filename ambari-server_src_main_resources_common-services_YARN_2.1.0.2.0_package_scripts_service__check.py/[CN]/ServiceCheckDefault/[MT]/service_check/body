def service_check(self, env):
    import params
    env.set_params(params)
    queue_for_check = params.yarn_default_queue_name
    yarn_queue_list = params.yarn_scheduler_capacity_root_queues.split(',')
    yarn_queue_list = list(filter((lambda x: x.strip()), yarn_queue_list))
    if ((params.yarn_default_queue_name not in yarn_queue_list) and (len(yarn_queue_list) > 0)):
        queue_for_check = yarn_queue_list[0]
        Logger.logger.info("No '{0}' queue present, using '{1}' instead".format(params.yarn_default_queue_name, queue_for_check))
    if ((params.stack_version_formatted_major != '') and (compare_versions(params.stack_version_formatted_major, '2.2') >= 0)):
        path_to_distributed_shell_jar = '/usr/hdp/current/hadoop-yarn-client/hadoop-yarn-applications-distributedshell.jar'
    else:
        path_to_distributed_shell_jar = '/usr/lib/hadoop-yarn/hadoop-yarn-applications-distributedshell*.jar'
    yarn_distrubuted_shell_check_params = ['yarn org.apache.hadoop.yarn.applications.distributedshell.Client', '-shell_command', 'ls', '-num_containers', '{number_of_nm}', '-jar', '{path_to_distributed_shell_jar}', '-timeout', '300000', '--queue', '{queue_for_check}']
    yarn_distrubuted_shell_check_cmd = format(' '.join(yarn_distrubuted_shell_check_params))
    if params.security_enabled:
        kinit_cmd = format('{kinit_path_local} -kt {smoke_user_keytab} {smokeuser_principal};')
        smoke_cmd = format('{kinit_cmd} {yarn_distrubuted_shell_check_cmd}')
    else:
        smoke_cmd = yarn_distrubuted_shell_check_cmd
    (return_code, out) = shell.checked_call(smoke_cmd, path='/usr/sbin:/sbin:/usr/local/bin:/bin:/usr/bin', user=params.smokeuser)
    m = re.search('appTrackingUrl=(.*),\\s', out)
    app_url = m.group(1)
    splitted_app_url = str(app_url).split('/')
    for item in splitted_app_url:
        if ('application' in item):
            application_name = item
    json_response_received = False
    for rm_webapp_address in params.rm_webapp_addresses_list:
        info_app_url = ((((params.scheme + '://') + rm_webapp_address) + '/ws/v1/cluster/apps/') + application_name)
        get_app_info_cmd = ((('curl --negotiate -u : -ksL --connect-timeout ' + CURL_CONNECTION_TIMEOUT) + ' ') + info_app_url)
        (return_code, stdout, _) = get_user_call_output(get_app_info_cmd, user=params.smokeuser, path='/usr/sbin:/sbin:/usr/local/bin:/bin:/usr/bin')
        try:
            json_response = json.loads(stdout)
            json_response_received = True
            if ((json_response['app']['state'] != 'FINISHED') or (json_response['app']['finalStatus'] != 'SUCCEEDED')):
                raise Exception((('Application ' + app_url) + ' state/status is not valid. Should be FINISHED/SUCCEEDED.'))
        except Exception as e:
            pass
    if (not json_response_received):
        raise Exception('Could not get json response from YARN API')
