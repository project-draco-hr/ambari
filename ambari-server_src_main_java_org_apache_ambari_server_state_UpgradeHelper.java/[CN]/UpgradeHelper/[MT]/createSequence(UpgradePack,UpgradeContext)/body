{
  context.setAmbariMetaInfo(m_ambariMetaInfo.get());
  Cluster cluster=context.getCluster();
  boolean forUpgrade=context.getDirection() == Direction.UPGRADE;
  MasterHostResolver mhr=context.getResolver();
  Map<String,Map<String,ProcessingComponent>> allTasks=upgradePack.getTasks();
  List<UpgradeGroupHolder> groups=new ArrayList<UpgradeGroupHolder>();
  for (  Grouping group : upgradePack.getGroups(forUpgrade)) {
    UpgradeGroupHolder groupHolder=new UpgradeGroupHolder();
    groupHolder.name=group.name;
    groupHolder.title=group.title;
    groupHolder.skippable=group.skippable;
    groupHolder.allowRetry=group.allowRetry;
    if (Direction.DOWNGRADE == context.getDirection()) {
      groupHolder.skippable=true;
    }
    StageWrapperBuilder builder=group.getBuilder();
    List<UpgradePack.OrderService> services=group.services;
    if (context.getDirection() == Direction.DOWNGRADE && !services.isEmpty()) {
      List<UpgradePack.OrderService> reverse=new ArrayList<UpgradePack.OrderService>(services);
      Collections.reverse(reverse);
      services=reverse;
    }
    for (    UpgradePack.OrderService service : services) {
      if (!allTasks.containsKey(service.serviceName)) {
        continue;
      }
      for (      String component : service.components) {
        if (!allTasks.get(service.serviceName).containsKey(component)) {
          continue;
        }
        HostsType hostsType=mhr.getMasterAndHosts(service.serviceName,component);
        if (null == hostsType) {
          continue;
        }
        if (!hostsType.unhealthy.isEmpty()) {
          context.addUnhealthy(hostsType.unhealthy);
        }
        Service svc=cluster.getService(service.serviceName);
        ProcessingComponent pc=allTasks.get(service.serviceName).get(component);
        if (service.serviceName.equalsIgnoreCase("HDFS") && component.equalsIgnoreCase("NAMENODE")) {
          if (hostsType.master != null && hostsType.secondary != null) {
            Set<String> order=new LinkedHashSet<String>();
            order.add(hostsType.secondary);
            order.add(hostsType.master);
            hostsType.hosts=order;
          }
 else {
            throw new AmbariException(MessageFormat.format("Could not find active and standby namenodes using hosts: {0}",StringUtils.join(hostsType.hosts,", ").toString()));
          }
          builder.add(hostsType,service.serviceName,forUpgrade,svc.isClientOnlyService(),pc);
        }
 else {
          builder.add(hostsType,service.serviceName,forUpgrade,svc.isClientOnlyService(),pc);
        }
      }
    }
    List<StageWrapper> proxies=builder.build(context);
    if (!proxies.isEmpty()) {
      groupHolder.items=proxies;
      postProcess(context,groupHolder);
      groups.add(groupHolder);
    }
  }
  if (LOG.isDebugEnabled()) {
    for (    UpgradeGroupHolder group : groups) {
      LOG.debug(group.name);
      int i=0;
      for (      StageWrapper proxy : group.items) {
        LOG.debug("  Stage {}",Integer.valueOf(i++));
        int j=0;
        for (        TaskWrapper task : proxy.getTasks()) {
          LOG.debug("    Task {} {}",Integer.valueOf(j++),task);
        }
      }
    }
  }
  return groups;
}
