{
  RepositoryInfo ri=getRepository(stackName,stackVersion,osType,repoId);
  if (!stackRoot.exists())   throw new StackAccessException("Stack root does not exist.");
  String repoFileName=stackRoot.getAbsolutePath() + File.separator + stackName+ File.separator+ stackVersion+ File.separator+ REPOSITORY_FOLDER_NAME+ File.separator+ REPOSITORY_FILE_NAME;
  File repoFile=new File(repoFileName);
  if (!repoFile.exists())   throw new StackAccessException("Stack repo file does not exist.");
  try {
    File newFile=new File(repoFileName + "." + System.currentTimeMillis());
    FileUtils.copyFile(repoFile,newFile,false);
    DocumentBuilderFactory dbFactory=DocumentBuilderFactory.newInstance();
    DocumentBuilder dBuilder=dbFactory.newDocumentBuilder();
    Document doc=dBuilder.parse(repoFile);
    NodeList osNodes=doc.getElementsByTagName(REPOSITORY_XML_MAIN_BLOCK_NAME);
    List<Node> newOsNodes=new ArrayList<Node>();
    for (int i=0; i < osNodes.getLength(); i++) {
      Node osNode=osNodes.item(i);
      if (osNode.getNodeType() != Node.ELEMENT_NODE) {
        continue;
      }
      NamedNodeMap attrs=osNode.getAttributes();
      Node osAttr=attrs.getNamedItem(REPOSITORY_XML_ATTRIBUTE_OS_TYPE);
      if (osAttr == null) {
        continue;
      }
      String xmlOsValue=osAttr.getNodeValue();
      if (-1 == xmlOsValue.indexOf(osType)) {
        continue;
      }
      Node template=osNode.cloneNode(true);
      String[] allOsTypes=osAttr.getNodeValue().split(",");
      for (      String xmlOsType : allOsTypes) {
        Node newOsNode=template.cloneNode(true);
        NamedNodeMap newAttrs=newOsNode.getAttributes();
        Node newOsAttr=newAttrs.getNamedItem(REPOSITORY_XML_ATTRIBUTE_OS_TYPE);
        newOsAttr.setTextContent(xmlOsType);
        if (xmlOsType.equals(osType)) {
          NodeList newOsNodeChildren=newOsNode.getChildNodes();
          for (int j=0; j < newOsNodeChildren.getLength(); j++) {
            Node repoNode=newOsNodeChildren.item(j);
            if (repoNode.getNodeName().equals(REPOSITORY_XML_REPO_BLOCK_NAME)) {
              Element property=(Element)repoNode;
              String xmlRepoId=getTagValue(REPOSITORY_XML_PROPERTY_REPOID,property);
              if (xmlRepoId.equals(repoId)) {
                NodeList nl=property.getElementsByTagName(REPOSITORY_XML_PROPERTY_BASEURL);
                if (null != nl && nl.getLength() > 0) {
                  String defaultBaseUrl=getTagValue(REPOSITORY_XML_PROPERTY_DEFAULT_BASEURL,property);
                  if (null == defaultBaseUrl) {
                    Node n=doc.createElement(REPOSITORY_XML_PROPERTY_DEFAULT_BASEURL);
                    n.setTextContent(nl.item(0).getTextContent());
                    if (null != ri)                     ri.setDefaultBaseUrl(nl.item(0).getTextContent());
                    property.appendChild(n);
                  }
                  nl.item(0).setTextContent(baseUrl);
                }
              }
            }
          }
          doc.getDocumentElement().replaceChild(newOsNode,osNode);
        }
 else {
          newOsNodes.add(newOsNode);
        }
      }
    }
    for (    Node n : newOsNodes) {
      doc.getDocumentElement().appendChild(n);
    }
    TransformerFactory tf=TransformerFactory.newInstance();
    Transformer t=tf.newTransformer();
    t.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION,"no");
    t.setOutputProperty(OutputKeys.METHOD,"xml");
    t.setOutputProperty(OutputKeys.INDENT,"yes");
    t.setOutputProperty(OutputKeys.ENCODING,"UTF-8");
    t.setOutputProperty("{http://xml.apache.org/xslt}indent-amount","2");
    doc.setXmlStandalone(true);
    t.transform(new DOMSource(doc),new StreamResult(repoFile));
  }
 catch (  Exception e) {
    throw new AmbariException(e.getMessage(),e);
  }
  if (null != ri) {
    ri.setBaseUrl(baseUrl);
  }
}
