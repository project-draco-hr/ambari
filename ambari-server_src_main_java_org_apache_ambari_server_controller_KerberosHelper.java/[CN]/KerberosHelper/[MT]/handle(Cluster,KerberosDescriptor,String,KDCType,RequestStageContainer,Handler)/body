{
  Map<String,Service> services=cluster.getServices();
  if ((services != null) && !services.isEmpty()) {
    SecurityState desiredSecurityState=handler.getNewServiceSecurityState();
    String clusterName=cluster.getClusterName();
    Map<String,Host> hosts=clusters.getHostsForCluster(clusterName);
    if ((hosts != null) && !hosts.isEmpty()) {
      List<ServiceComponentHost> serviceComponentHostsToProcess=new ArrayList<ServiceComponentHost>();
      File indexFile;
      kerberosDescriptor=buildKerberosDescriptor(cluster.getCurrentStackVersion(),kerberosDescriptor);
      KerberosActionDataFileBuilder kerberosActionDataFileBuilder=null;
      Map<String,String> kerberosDescriptorProperties=kerberosDescriptor.getProperties();
      Map<String,Map<String,String>> kerberosConfigurations=new HashMap<String,Map<String,String>>();
      AuthToLocalBuilder authToLocalBuilder=new AuthToLocalBuilder();
      File dataDirectory;
      try {
        dataDirectory=createTemporaryDirectory();
      }
 catch (      IOException e) {
        String message="Failed to create the temporary data directory.";
        LOG.error(message,e);
        throw new AmbariException(message,e);
      }
      indexFile=new File(dataDirectory,KerberosActionDataFile.DATA_FILE_NAME);
      try {
        for (        Host host : hosts.values()) {
          if (host.getState() == HostState.HEALTHY) {
            String hostname=host.getHostName();
            List<ServiceComponentHost> serviceComponentHosts=cluster.getServiceComponentHosts(hostname);
            if ((serviceComponentHosts != null) && !serviceComponentHosts.isEmpty()) {
              Map<String,Map<String,String>> configurations=calculateConfigurations(cluster,hostname);
              Map<String,String> generalProperties=new HashMap<String,String>();
              if (configurations == null) {
                configurations=new HashMap<String,Map<String,String>>();
              }
              if (kerberosDescriptorProperties != null) {
                generalProperties.putAll(kerberosDescriptorProperties);
              }
              generalProperties.put("host",hostname);
              generalProperties.put("hostname",hostname);
              if (configurations.get("") == null) {
                configurations.put("",generalProperties);
              }
 else {
                configurations.get("").putAll(generalProperties);
              }
              for (              ServiceComponentHost sch : serviceComponentHosts) {
                String serviceName=sch.getServiceName();
                KerberosServiceDescriptor serviceDescriptor=kerberosDescriptor.getService(serviceName);
                if (serviceDescriptor != null) {
                  KerberosComponentDescriptor componentDescriptor=serviceDescriptor.getComponent(sch.getServiceComponentName());
                  List<KerberosIdentityDescriptor> serviceIdentities=serviceDescriptor.getIdentities(true);
                  if (componentDescriptor != null) {
                    List<KerberosIdentityDescriptor> componentIdentities=componentDescriptor.getIdentities(true);
                    int identitiesAdded=0;
                    if (handler.shouldProcess(desiredSecurityState,sch)) {
                      mergeConfigurations(kerberosConfigurations,componentDescriptor.getConfigurations(true),configurations);
                      if (kerberosActionDataFileBuilder == null) {
                        kerberosActionDataFileBuilder=new KerberosActionDataFileBuilder(indexFile);
                      }
                      identitiesAdded+=addIdentities(kerberosActionDataFileBuilder,serviceIdentities,sch,configurations);
                      identitiesAdded+=addIdentities(kerberosActionDataFileBuilder,componentIdentities,sch,configurations);
                      if (identitiesAdded > 0) {
                        serviceComponentHostsToProcess.add(sch);
                      }
                    }
                    addIdentities(authToLocalBuilder,componentIdentities,configurations);
                  }
                  addIdentities(authToLocalBuilder,serviceIdentities,configurations);
                }
              }
            }
          }
        }
      }
 catch (      IOException e) {
        String message=String.format("Failed to write index file - %s",indexFile.getAbsolutePath());
        LOG.error(message);
        throw new AmbariException(message,e);
      }
 finally {
        if (kerberosActionDataFileBuilder != null) {
          try {
            kerberosActionDataFileBuilder.close();
          }
 catch (          IOException e) {
            LOG.warn("Failed to close the index file writer",e);
          }
        }
      }
      if (!serviceComponentHostsToProcess.isEmpty()) {
        try {
          String credentials=getEncryptedAdministratorCredentials(cluster);
          if (credentials == null) {
            throw new IllegalArgumentException("Missing KDC administrator credentials.\n" + "The KDC administrator credentials must be set in session by updating the relevant Cluster resource." + "This may be done by issuing a PUT to the api/v1/clusters/(cluster name) API entry point with the following payload:\n"+ "{\n"+ "  \"session_attributes\" : {\n"+ "    \"kerberos_admin\" : {\"principal\" : \"(PRINCIPAL)\", \"password\" : \"(PASSWORD)\"}\n"+ "  }\n"+ "}");
          }
 else {
            KerberosOperationHandler operationHandler=kerberosOperationHandlerFactory.getKerberosOperationHandler(kdcType);
            if (operationHandler == null) {
              throw new AmbariException("Failed to get an appropriate Kerberos operation handler.");
            }
 else {
              byte[] key=Integer.toHexString(cluster.hashCode()).getBytes();
              KerberosCredential kerberosCredentials=KerberosCredential.decrypt(credentials,key);
              try {
                operationHandler.open(kerberosCredentials,realm);
                if (!operationHandler.testAdministratorCredentials()) {
                  throw new IllegalArgumentException("Invalid KDC administrator credentials.\n" + "The KDC administrator credentials must be set in session by updating the relevant Cluster resource." + "This may be done by issuing a PUT to the api/v1/clusters/(cluster name) API entry point with the following payload:\n"+ "{\n"+ "  \"session_attributes\" : {\n"+ "    \"kerberos_admin\" : {\"principal\" : \"(PRINCIPAL)\", \"password\" : \"(PASSWORD)\"}\n"+ "  }\n"+ "}");
                }
              }
 catch (              KerberosAdminAuthenticationException e) {
                throw new IllegalArgumentException("Invalid KDC administrator credentials.\n" + "The KDC administrator credentials must be set in session by updating the relevant Cluster resource." + "This may be done by issuing a PUT to the api/v1/clusters/(cluster name) API entry point with the following payload:\n"+ "{\n"+ "  \"session_attributes\" : {\n"+ "    \"kerberos_admin\" : {\"principal\" : \"(PRINCIPAL)\", \"password\" : \"(PASSWORD)\"}\n"+ "  }\n"+ "}",e);
              }
catch (              KerberosKDCConnectionException e) {
                throw new AmbariException("Failed to connect to KDC - " + e.getMessage() + "\n"+ "Update the KDC settings in krb5-conf and kerberos-env configurations to correct this issue.",e);
              }
catch (              KerberosOperationException e) {
                throw new AmbariException(e.getMessage(),e);
              }
 finally {
                try {
                  operationHandler.close();
                }
 catch (                KerberosOperationException e) {
                }
              }
            }
          }
        }
 catch (        IllegalArgumentException e) {
          try {
            FileUtils.deleteDirectory(dataDirectory);
          }
 catch (          Throwable t) {
            LOG.warn(String.format("The data directory (%s) was not deleted due to an error condition - {%s}",dataDirectory.getAbsolutePath(),t.getMessage()),t);
          }
          throw e;
        }
        String authToLocal=null;
        for (        Map<String,String> configuration : kerberosConfigurations.values()) {
          for (          Map.Entry<String,String> entry : configuration.entrySet()) {
            if ("_AUTH_TO_LOCAL_RULES".equals(entry.getValue())) {
              if (authToLocal == null) {
                authToLocal=authToLocalBuilder.generate(realm);
              }
              entry.setValue(authToLocal);
            }
          }
        }
      }
      Map<String,Set<String>> clusterHostInfo=StageUtils.getClusterHostInfo(hosts,cluster);
      String clusterHostInfoJson=StageUtils.getGson().toJson(clusterHostInfo);
      Map<String,String> hostParams=customCommandExecutionHelper.createDefaultHostParams(cluster);
      String hostParamsJson=StageUtils.getGson().toJson(hostParams);
      String ambariServerHostname=StageUtils.getHostName();
      ServiceComponentHostServerActionEvent event=new ServiceComponentHostServerActionEvent("AMBARI_SERVER",ambariServerHostname,System.currentTimeMillis());
      RoleCommandOrder roleCommandOrder=ambariManagementController.getRoleCommandOrder(cluster);
      if (requestStageContainer == null) {
        requestStageContainer=new RequestStageContainer(actionManager.getNextRequestId(),null,requestFactory,actionManager);
      }
      int lastStageId=handler.createStages(cluster,hosts,kerberosConfigurations,clusterHostInfoJson,hostParamsJson,event,roleCommandOrder,realm,kdcType.toString(),dataDirectory,requestStageContainer,serviceComponentHostsToProcess);
      Map<String,String> commandParameters=new HashMap<String,String>();
      commandParameters.put(KerberosServerAction.DATA_DIRECTORY,dataDirectory.getAbsolutePath());
      Stage stage=createServerActionStage(++lastStageId,cluster,requestStageContainer.getId(),"Process Kerberos Operations",clusterHostInfoJson,"{}",hostParamsJson,FinalizeKerberosServerAction.class,event,commandParameters,"Finalize Operations",300);
      RoleGraph roleGraph=new RoleGraph(roleCommandOrder);
      roleGraph.build(stage);
      requestStageContainer.addStages(roleGraph.getStages());
      for (      ServiceComponentHost sch : serviceComponentHostsToProcess) {
        sch.setDesiredSecurityState(handler.getNewDesiredSCHSecurityState());
        sch.setSecurityState(handler.getNewSCHSecurityState());
      }
    }
    for (    Service service : services.values()) {
      service.setSecurityState(desiredSecurityState);
    }
  }
  return requestStageContainer;
}
