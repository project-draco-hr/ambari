{
  Map<String,Service> services=cluster.getServices();
  if ((services != null) && !services.isEmpty()) {
    SecurityState desiredSecurityState=handler.getNewServiceSecurityState();
    String clusterName=cluster.getClusterName();
    Map<String,Host> hosts=clusters.getHostsForCluster(clusterName);
    if ((hosts != null) && !hosts.isEmpty()) {
      List<ServiceComponentHost> serviceComponentHostsToProcess=new ArrayList<ServiceComponentHost>();
      File indexFile;
      kerberosDescriptor=buildKerberosDescriptor(cluster.getCurrentStackVersion(),kerberosDescriptor);
      KerberosActionDataFileBuilder kerberosActionDataFileBuilder=null;
      Map<String,String> kerberosDescriptorProperties=kerberosDescriptor.getProperties();
      Map<String,Map<String,String>> kerberosConfigurations=new HashMap<String,Map<String,String>>();
      AuthToLocalBuilder authToLocalBuilder=new AuthToLocalBuilder();
      File dataDirectory;
      try {
        dataDirectory=createTemporaryDirectory();
      }
 catch (      IOException e) {
        String message="Failed to create the temporary data directory.";
        LOG.error(message,e);
        throw new AmbariException(message,e);
      }
      indexFile=new File(dataDirectory,KerberosActionDataFile.DATA_FILE_NAME);
      try {
        for (        Host host : hosts.values()) {
          if (host.getState() == HostState.HEALTHY) {
            String hostname=host.getHostName();
            List<ServiceComponentHost> serviceComponentHosts=cluster.getServiceComponentHosts(hostname);
            if ((serviceComponentHosts != null) && !serviceComponentHosts.isEmpty()) {
              Map<String,Map<String,String>> configurations=calculateConfigurations(cluster,hostname);
              Map<String,String> generalProperties=new HashMap<String,String>();
              if (configurations == null) {
                configurations=new HashMap<String,Map<String,String>>();
              }
              if (kerberosDescriptorProperties != null) {
                generalProperties.putAll(kerberosDescriptorProperties);
              }
              generalProperties.put("host",hostname);
              generalProperties.put("hostname",hostname);
              generalProperties.put("cluster_name",clusterName);
              if (configurations.get("") == null) {
                configurations.put("",generalProperties);
              }
 else {
                configurations.get("").putAll(generalProperties);
              }
              for (              ServiceComponentHost sch : serviceComponentHosts) {
                String serviceName=sch.getServiceName();
                if ((serviceComponentFilter == null) || serviceComponentFilter.containsKey(serviceName)) {
                  Collection<String> componentFilter=(serviceComponentFilter == null) ? null : serviceComponentFilter.get(serviceName);
                  KerberosServiceDescriptor serviceDescriptor=kerberosDescriptor.getService(serviceName);
                  if (serviceDescriptor != null) {
                    String componentName=sch.getServiceComponentName();
                    if (((componentFilter == null) || componentFilter.contains(componentName)) && handler.shouldProcess(desiredSecurityState,sch)) {
                      KerberosComponentDescriptor componentDescriptor=serviceDescriptor.getComponent(componentName);
                      List<KerberosIdentityDescriptor> serviceIdentities=serviceDescriptor.getIdentities(true);
                      if (componentDescriptor != null) {
                        List<KerberosIdentityDescriptor> componentIdentities=componentDescriptor.getIdentities(true);
                        int identitiesAdded=0;
                        mergeConfigurations(kerberosConfigurations,componentDescriptor.getConfigurations(true),configurations);
                        if (kerberosActionDataFileBuilder == null) {
                          kerberosActionDataFileBuilder=new KerberosActionDataFileBuilder(indexFile);
                        }
                        identitiesAdded+=addIdentities(kerberosActionDataFileBuilder,serviceIdentities,identityFilter,hostname,serviceName,componentName,configurations);
                        identitiesAdded+=addIdentities(kerberosActionDataFileBuilder,componentIdentities,identityFilter,hostname,serviceName,componentName,configurations);
                        if (identitiesAdded > 0) {
                          serviceComponentHostsToProcess.add(sch);
                        }
                        addIdentities(authToLocalBuilder,componentIdentities,identityFilter,configurations);
                      }
                      addIdentities(authToLocalBuilder,serviceIdentities,identityFilter,configurations);
                    }
                  }
                }
              }
            }
          }
        }
      }
 catch (      IOException e) {
        String message=String.format("Failed to write index file - %s",indexFile.getAbsolutePath());
        LOG.error(message);
        throw new AmbariException(message,e);
      }
 finally {
        if (kerberosActionDataFileBuilder != null) {
          try {
            kerberosActionDataFileBuilder.close();
          }
 catch (          IOException e) {
            LOG.warn("Failed to close the index file writer",e);
          }
        }
      }
      if (!serviceComponentHostsToProcess.isEmpty()) {
        try {
          String credentials=getEncryptedAdministratorCredentials(cluster);
          if (credentials == null) {
            throw new IllegalArgumentException("Missing KDC administrator credentials.\n" + "The KDC administrator credentials must be set in session by updating the relevant Cluster resource." + "This may be done by issuing a PUT to the api/v1/clusters/(cluster name) API entry point with the following payload:\n"+ "{\n"+ "  \"session_attributes\" : {\n"+ "    \"kerberos_admin\" : {\"principal\" : \"(PRINCIPAL)\", \"password\" : \"(PASSWORD)\"}\n"+ "  }\n"+ "}");
          }
 else {
            KerberosOperationHandler operationHandler=kerberosOperationHandlerFactory.getKerberosOperationHandler(kerberosDetails.getKdcType());
            if (operationHandler == null) {
              throw new AmbariException("Failed to get an appropriate Kerberos operation handler.");
            }
 else {
              byte[] key=Integer.toHexString(cluster.hashCode()).getBytes();
              KerberosCredential kerberosCredentials=KerberosCredential.decrypt(credentials,key);
              try {
                operationHandler.open(kerberosCredentials,kerberosDetails.getDefaultRealm(),kerberosDetails.getKerberosEnvProperties());
                if (!operationHandler.testAdministratorCredentials()) {
                  throw new IllegalArgumentException("Invalid KDC administrator credentials.\n" + "The KDC administrator credentials must be set in session by updating the relevant Cluster resource." + "This may be done by issuing a PUT to the api/v1/clusters/(cluster name) API entry point with the following payload:\n"+ "{\n"+ "  \"session_attributes\" : {\n"+ "    \"kerberos_admin\" : {\"principal\" : \"(PRINCIPAL)\", \"password\" : \"(PASSWORD)\"}\n"+ "  }\n"+ "}");
                }
              }
 catch (              KerberosAdminAuthenticationException e) {
                throw new IllegalArgumentException("Invalid KDC administrator credentials.\n" + "The KDC administrator credentials must be set in session by updating the relevant Cluster resource." + "This may be done by issuing a PUT to the api/v1/clusters/(cluster name) API entry point with the following payload:\n"+ "{\n"+ "  \"session_attributes\" : {\n"+ "    \"kerberos_admin\" : {\"principal\" : \"(PRINCIPAL)\", \"password\" : \"(PASSWORD)\"}\n"+ "  }\n"+ "}",e);
              }
catch (              KerberosKDCConnectionException e) {
                throw new IllegalArgumentException("Failed to connect to KDC - " + e.getMessage() + "\n"+ "Update the KDC settings in krb5-conf and kerberos-env configurations to correct this issue.",e);
              }
catch (              KerberosRealmException e) {
                throw new IllegalArgumentException("Failed to find a KDC for the specified realm - " + e.getMessage() + "\n"+ "Update the KDC settings in krb5-conf and kerberos-env configurations to correct this issue.",e);
              }
catch (              KerberosLDAPContainerException e) {
                throw new IllegalArgumentException("The principal container was not specified\n" + "Set the 'container_dn' value in the kerberos-env configuration to correct this issue.",e);
              }
catch (              KerberosOperationException e) {
                throw new AmbariException(e.getMessage(),e);
              }
 finally {
                try {
                  operationHandler.close();
                }
 catch (                KerberosOperationException e) {
                }
              }
            }
          }
        }
 catch (        IllegalArgumentException e) {
          try {
            FileUtils.deleteDirectory(dataDirectory);
          }
 catch (          Throwable t) {
            LOG.warn(String.format("The data directory (%s) was not deleted due to an error condition - {%s}",dataDirectory.getAbsolutePath(),t.getMessage()),t);
          }
          throw e;
        }
        String authToLocal=null;
        for (        Map<String,String> configuration : kerberosConfigurations.values()) {
          for (          Map.Entry<String,String> entry : configuration.entrySet()) {
            if ("_AUTH_TO_LOCAL_RULES".equals(entry.getValue())) {
              if (authToLocal == null) {
                authToLocal=authToLocalBuilder.generate(kerberosDetails.getDefaultRealm());
              }
              entry.setValue(authToLocal);
            }
          }
        }
      }
      Map<String,String> clusterEnvProperties=kerberosConfigurations.get("cluster-env");
      if (clusterEnvProperties == null) {
        clusterEnvProperties=new HashMap<String,String>();
        kerberosConfigurations.put("cluster-env",clusterEnvProperties);
      }
      clusterEnvProperties.put("security_enabled",(kerberosDetails.getSecurityType() == SecurityType.KERBEROS) ? "true" : "false");
      Map<String,Set<String>> clusterHostInfo=StageUtils.getClusterHostInfo(hosts,cluster);
      String clusterHostInfoJson=StageUtils.getGson().toJson(clusterHostInfo);
      Map<String,String> hostParams=customCommandExecutionHelper.createDefaultHostParams(cluster);
      String hostParamsJson=StageUtils.getGson().toJson(hostParams);
      String ambariServerHostname=StageUtils.getHostName();
      ServiceComponentHostServerActionEvent event=new ServiceComponentHostServerActionEvent("AMBARI_SERVER",ambariServerHostname,System.currentTimeMillis());
      RoleCommandOrder roleCommandOrder=ambariManagementController.getRoleCommandOrder(cluster);
      if (requestStageContainer == null) {
        requestStageContainer=new RequestStageContainer(actionManager.getNextRequestId(),null,requestFactory,actionManager);
      }
      handler.createStages(cluster,hosts,kerberosConfigurations,clusterHostInfoJson,hostParamsJson,event,roleCommandOrder,kerberosDetails,dataDirectory,requestStageContainer,serviceComponentHostsToProcess);
      Map<String,String> commandParameters=new HashMap<String,String>();
      commandParameters.put(KerberosServerAction.DATA_DIRECTORY,dataDirectory.getAbsolutePath());
      Stage stage=createServerActionStage(requestStageContainer.getLastStageId(),cluster,requestStageContainer.getId(),"Finalize Operations",clusterHostInfoJson,"{}",hostParamsJson,FinalizeKerberosServerAction.class,event,commandParameters,"Finalize Operations",300);
      RoleGraph roleGraph=new RoleGraph(roleCommandOrder);
      roleGraph.build(stage);
      requestStageContainer.addStages(roleGraph.getStages());
      for (      ServiceComponentHost sch : serviceComponentHostsToProcess) {
        SecurityState newSecurityState;
        newSecurityState=handler.getNewDesiredSCHSecurityState();
        if (newSecurityState != null) {
          sch.setDesiredSecurityState(newSecurityState);
        }
        newSecurityState=handler.getNewSCHSecurityState();
        if (newSecurityState != null) {
          sch.setSecurityState(newSecurityState);
        }
      }
    }
    if (desiredSecurityState != null) {
      for (      Service service : services.values()) {
        service.setSecurityState(desiredSecurityState);
      }
    }
  }
  return requestStageContainer;
}
