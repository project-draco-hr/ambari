def _call(command, log_stdout=False, throw_on_failure=True, cwd=None, env=None, preexec_fn=None):
    "\n  Execute shell command\n  \n  @param command: list/tuple of arguments (recommended as more safe - don't need to escape) \n  or string of the command to execute\n  @param log_stdout: boolean, whether command output should be logged of not\n  @param throw_on_failure: if true, when return code is not zero exception is thrown\n  \n  @return: retrun_code, stdout, stderr\n  "
    if isinstance(command, (list, tuple)):
        shell = False
    else:
        shell = True
    proc = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=cwd, env=env, shell=shell, preexec_fn=preexec_fn)
    out = proc.communicate()[0]
    code = proc.wait()
    if (throw_on_failure and code):
        err_msg = ("Execution of '%s' returned %d: Error: %s" % (command, code, out))
        raise Fail(err_msg)
    if log_stdout:
        _log.info(('%s.\n%s' % (command, out)))
    return (code, out)
