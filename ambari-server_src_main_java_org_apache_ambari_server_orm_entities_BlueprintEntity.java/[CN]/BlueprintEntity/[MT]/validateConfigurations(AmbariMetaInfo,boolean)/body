{
  StackEntity stack=getStack();
  String stackName=stack.getStackName();
  String stackVersion=stack.getStackVersion();
  Map<String,Map<String,Collection<String>>> missingProperties=new HashMap<String,Map<String,Collection<String>>>();
  Map<String,Map<String,String>> clusterConfigurations=getConfigurationAsMap(getConfigurations());
  for (  HostGroupEntity hostGroup : getHostGroups()) {
    Collection<String> processedServices=new HashSet<String>();
    Map<String,Collection<String>> allRequiredProperties=new HashMap<String,Collection<String>>();
    Map<String,Map<String,String>> operationalConfiguration=new HashMap<String,Map<String,String>>(clusterConfigurations);
    operationalConfiguration.putAll(getConfigurationAsMap(hostGroup.getConfigurations()));
    for (    HostGroupComponentEntity component : hostGroup.getComponents()) {
      if (component.getName().equals("MYSQL_SERVER")) {
        Map<String,String> hiveEnvConfig=clusterConfigurations.get("hive-env");
        if (hiveEnvConfig != null && !hiveEnvConfig.isEmpty() && hiveEnvConfig.get("hive_database") != null && hiveEnvConfig.get("hive_database").startsWith("Existing")) {
          throw new IllegalArgumentException("Incorrect configuration: MYSQL_SERVER component is available but hive" + " using existing db!");
        }
      }
      if (!component.getName().equals("AMBARI_SERVER")) {
        ServiceInfo service;
        String serviceName;
        try {
          serviceName=stackInfo.getComponentToService(stackName,stackVersion,component.getName());
          service=stackInfo.getService(stackName,stackVersion,serviceName);
        }
 catch (        AmbariException e) {
          throw new IllegalArgumentException("Unable to determine the service associated with the" + " component: " + component.getName());
        }
        if (processedServices.add(serviceName)) {
          Map<String,PropertyInfo> serviceRequirements=service.getRequiredProperties();
          for (          PropertyInfo propertyInfo : serviceRequirements.values()) {
            if (!(validatePasswords ^ propertyInfo.getPropertyTypes().contains(PropertyInfo.PropertyType.PASSWORD))) {
              String configCategory=propertyInfo.getFilename();
              if (configCategory.endsWith(".xml")) {
                configCategory=configCategory.substring(0,configCategory.indexOf(".xml"));
              }
              Collection<String> typeRequirements=allRequiredProperties.get(configCategory);
              if (typeRequirements == null) {
                typeRequirements=new HashSet<String>();
                allRequiredProperties.put(configCategory,typeRequirements);
              }
              typeRequirements.add(propertyInfo.getName());
            }
          }
        }
      }
    }
    for (    Map.Entry<String,Collection<String>> requiredTypeProperties : allRequiredProperties.entrySet()) {
      String requiredCategory=requiredTypeProperties.getKey();
      Collection<String> requiredProperties=requiredTypeProperties.getValue();
      Collection<String> operationalTypeProps=operationalConfiguration.containsKey(requiredCategory) ? operationalConfiguration.get(requiredCategory).keySet() : Collections.<String>emptyList();
      requiredProperties.removeAll(operationalTypeProps);
      if (!requiredProperties.isEmpty()) {
        String hostGroupName=hostGroup.getName();
        Map<String,Collection<String>> hostGroupMissingProps=missingProperties.get(hostGroupName);
        if (hostGroupMissingProps == null) {
          hostGroupMissingProps=new HashMap<String,Collection<String>>();
          missingProperties.put(hostGroupName,hostGroupMissingProps);
        }
        hostGroupMissingProps.put(requiredCategory,requiredProperties);
      }
    }
  }
  return missingProperties;
}
