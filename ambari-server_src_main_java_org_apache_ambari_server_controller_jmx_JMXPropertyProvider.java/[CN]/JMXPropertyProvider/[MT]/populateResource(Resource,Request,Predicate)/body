{
  Set<String> ids=getRequestPropertyIds(request,predicate);
  if (ids.isEmpty()) {
    return true;
  }
  String clusterName=(String)resource.getPropertyValue(clusterNamePropertyId);
  String componentName=(String)resource.getPropertyValue(componentNamePropertyId);
  String port=jmxHostProvider.getPort(clusterName,componentName);
  String hostName;
  if (hostNamePropertyId == null) {
    hostName=jmxHostProvider.getHostName(clusterName,componentName);
  }
 else {
    hostName=(String)resource.getPropertyValue(hostNamePropertyId);
  }
  if (getComponentMetrics().get(componentName) == null || hostName == null || port == null) {
    return true;
  }
  String spec=getSpec(hostName + ":" + port);
  InputStream in=null;
  try {
    in=streamProvider.readFrom(spec);
    JMXMetricHolder metricHolder=objectReader.readValue(in);
    Map<String,Map<String,Object>> categories=new HashMap<String,Map<String,Object>>();
    for (    Map<String,Object> bean : metricHolder.getBeans()) {
      String category=getCategory(bean);
      if (category != null) {
        categories.put(category,bean);
      }
    }
    for (    String propertyId : ids) {
      Map<String,PropertyInfo> propertyInfoMap=getPropertyInfoMap(componentName,propertyId);
      for (      Map.Entry<String,PropertyInfo> entry : propertyInfoMap.entrySet()) {
        PropertyInfo propertyInfo=entry.getValue();
        propertyId=entry.getKey();
        if (propertyInfo.isPointInTime()) {
          String property=propertyInfo.getPropertyId();
          String category="";
          List<String> keyList=new LinkedList<String>();
          int keyStartIndex=property.indexOf('[',0);
          int firstKeyIndex=keyStartIndex > -1 ? keyStartIndex : property.length();
          while (keyStartIndex > -1) {
            int keyEndIndex=property.indexOf(']',keyStartIndex);
            if (keyEndIndex > -1 & keyEndIndex > keyStartIndex) {
              keyList.add(property.substring(keyStartIndex + 1,keyEndIndex));
              keyStartIndex=property.indexOf('[',keyEndIndex);
            }
 else {
              keyStartIndex=-1;
            }
          }
          int dotIndex=property.lastIndexOf('.',firstKeyIndex - 1);
          if (dotIndex != -1) {
            category=property.substring(0,dotIndex);
            property=property.substring(dotIndex + 1,firstKeyIndex);
          }
          Map<String,Object> properties=categories.get(category);
          if (properties != null && properties.containsKey(property)) {
            Object value=properties.get(property);
            if (keyList.size() > 0 && value instanceof Map) {
              Map map=(Map)value;
              for (              String key : keyList) {
                value=map.get(key);
                if (value instanceof Map) {
                  map=(Map)value;
                }
 else {
                  break;
                }
              }
            }
            resource.setProperty(propertyId,value);
          }
        }
      }
    }
  }
 catch (  IOException e) {
    if (LOG.isErrorEnabled()) {
      LOG.error("Caught exception getting JMX metrics : spec=" + spec,e);
    }
  }
 finally {
    if (in != null) {
      try {
        in.close();
      }
 catch (      IOException e) {
        if (LOG.isWarnEnabled()) {
          LOG.warn("Unable to close http input steam : spec=" + spec,e);
        }
      }
    }
  }
  return true;
}
