def heartbeatWithServer(self):
    self.DEBUG_HEARTBEAT_RETRIES = 0
    self.DEBUG_SUCCESSFULL_HEARTBEATS = 0
    retry = False
    certVerifFailed = False
    hb_interval = self.config.get('heartbeat', 'state_interval')
    while (not self.DEBUG_STOP_HEARTBEATING):
        try:
            if (not retry):
                data = json.dumps(self.heartbeat.build(self.responseId, int(hb_interval), self.hasMappedComponents))
                pass
            else:
                self.DEBUG_HEARTBEAT_RETRIES += 1
            if logger.isEnabledFor(logging.DEBUG):
                logger.debug('Sending Heartbeat (id = %s): %s', self.responseId, data)
            response = self.sendRequest(self.heartbeatUrl, data)
            exitStatus = 0
            if ('exitstatus' in response.keys()):
                exitStatus = int(response['exitstatus'])
            if (exitStatus != 0):
                raise Exception(response)
            serverId = int(response['responseId'])
            if logger.isEnabledFor(logging.DEBUG):
                logger.debug('Heartbeat response (id = %s): %s', serverId, pprint.pformat(response))
            else:
                logger.info('Heartbeat response received (id = %s)', serverId)
            if ('hasMappedComponents' in response.keys()):
                self.hasMappedComponents = (response['hasMappedComponents'] is not False)
            if ('registrationCommand' in response.keys()):
                if (response['registrationCommand'] is not None):
                    logger.info('RegistrationCommand received - repeat agent registration')
                    self.isRegistered = False
                    self.repeatRegistration = True
                    return
            if (serverId != (self.responseId + 1)):
                logger.error('Error in responseId sequence - restarting')
                self.restartAgent()
            else:
                self.responseId = serverId
            if ('cancelCommands' in response.keys()):
                self.cancelCommandInQueue(response['cancelCommands'])
                pass
            if ('executionCommands' in response.keys()):
                self.addToQueue(response['executionCommands'])
                pass
            if ('statusCommands' in response.keys()):
                self.addToStatusQueue(response['statusCommands'])
                pass
            if ('alertDefinitionCommands' in response.keys()):
                self.alert_scheduler_handler.update_definitions(response['alertDefinitionCommands'], True)
                pass
            if ('true' == response['restartAgent']):
                logger.error('Received the restartAgent command')
                self.restartAgent()
            else:
                logger.info('No commands sent from %s', self.serverHostname)
                pass
            if retry:
                logger.info('Reconnected to %s', self.heartbeatUrl)
            retry = False
            certVerifFailed = False
            self.DEBUG_SUCCESSFULL_HEARTBEATS += 1
            self.DEBUG_HEARTBEAT_RETRIES = 0
            self.heartbeat_wait_event.clear()
        except ssl.SSLError:
            self.repeatRegistration = False
            self.isRegistered = False
            return
        except Exception as err:
            if ('code' in err):
                logger.error(err.code)
            else:
                logException = False
                if logger.isEnabledFor(logging.DEBUG):
                    logException = True
                exceptionMessage = str(err)
                errorMessage = 'Unable to reconnect to {0} (attempts={1}, details={2})'.format(self.heartbeatUrl, self.DEBUG_HEARTBEAT_RETRIES, exceptionMessage)
                if (not retry):
                    errorMessage = 'Connection to {0} was lost (details={1})'.format(self.serverHostname, exceptionMessage)
                logger.error(errorMessage, exc_info=logException)
                if (('certificate verify failed' in str(err)) and (not certVerifFailed)):
                    logger.warn('Server certificate verify failed. Did you regenerate server certificate?')
                    certVerifFailed = True
            self.cachedconnect = None
            retry = True
            delay = randint(0, self.range)
            time.sleep(delay)
        timeout = (self.netutil.HEARTBEAT_IDDLE_INTERVAL_SEC - self.netutil.MINIMUM_INTERVAL_BETWEEN_HEARTBEATS)
        self.heartbeat_wait_event.wait(timeout=timeout)
        time.sleep(self.netutil.MINIMUM_INTERVAL_BETWEEN_HEARTBEATS)
    pass
