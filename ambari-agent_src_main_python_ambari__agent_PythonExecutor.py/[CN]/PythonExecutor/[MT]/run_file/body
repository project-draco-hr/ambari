def run_file(self, script, script_params, tmp_dir, tmpoutfile, tmperrfile, timeout, tmpstructedoutfile, logger_level, callback, task_id, override_output_files=True, handle=None):
    '\n    Executes the specified python file in a separate subprocess.\n    Method returns only when the subprocess is finished.\n    Params arg is a list of script parameters\n    Timeout meaning: how many seconds should pass before script execution\n    is forcibly terminated\n    override_output_files option defines whether stdout/stderr files will be\n    recreated or appended\n    '
    try:
        os.unlink(tmpstructedoutfile)
    except OSError:
        pass
    script_params += [tmpstructedoutfile, logger_level, tmp_dir]
    pythonCommand = self.python_command(script, script_params)
    logger.info(('Running command ' + pprint.pformat(pythonCommand)))
    if (handle == None):
        (tmpout, tmperr) = self.open_subporcess_files(tmpoutfile, tmperrfile, override_output_files)
        process = self.launch_python_subprocess(pythonCommand, tmpout, tmperr)
        callback(task_id, process.pid)
        logger.debug('Launching watchdog thread')
        self.event.clear()
        self.python_process_has_been_killed = False
        thread = Thread(target=self.python_watchdog_func, args=(process, timeout))
        thread.start()
        process.communicate()
        self.event.set()
        thread.join()
        return self.prepare_process_result(process, tmpoutfile, tmperrfile, tmpstructedoutfile)
    else:
        holder = Holder(pythonCommand, tmpoutfile, tmperrfile, tmpstructedoutfile, handle)
        background = BackgroundThread(holder, self)
        background.start()
        return {'exitcode': 777, }
