def handle_dfs_data_dir(func, params, update_cache=True):
    "\n  This function determine which DFS data dir paths can be created.\n  There are 2 uses cases:\n  1. Customers that have many DFS data dirs, each one on a separate mount point that corresponds to a different drive.\n  2. Developers that are using a sandbox VM and all DFS data dirs are mounted on the root.\n\n  The goal is to avoid forcefully creating a DFS data dir when a user's drive fails. In this scenario, the\n  mount point for a DFS data dir changes from something like /hadoop/hdfs/data/data1 to /\n  If Ambari forcefully creates the directory when it doesn't exist and drive became unmounted, then Ambari will soon\n  fill up the root drive, which is bad. Instead, we should not create the directory and let HDFS handle the failure\n  based on its tolerance of missing directories.\n\n  This function relies on the dfs.datanode.data.dir.mount.file parameter to parse a file that contains\n  a mapping from a DFS data dir, and its last known mount point.\n  After determining which DFS data dirs can be created if they don't exist, it recalculates the mount points and\n  writes to the file again.\n  :param func: Function that will be called if a directory will be created. This function\n               will be called as func(data_dir, params)\n  :param params: parameters to pass to function pointer\n  :param update_cache: Bool indicating whether to update the global cache of mount points\n  :return: Returns a data_dir_mount_file content\n  "
    prev_data_dir_to_mount_point = get_data_dir_to_mount_from_file(params)
    data_dir_to_mount_point = prev_data_dir_to_mount_point.copy()
    allowed_to_create_any_dir = False
    if (params.data_dir_mount_file is None):
        allowed_to_create_any_dir = True
        Logger.warning('DataNode is allowed to create any data directory since dfs.datanode.data.dir.mount.file property is null.')
    elif (not os.path.exists(params.data_dir_mount_file)):
        allowed_to_create_any_dir = True
        Logger.warning(('DataNode is allowed to create any data directory since dfs.datanode.data.dir.mount.file property has file %s and it does not exist.' % params.data_dir_mount_file))
    valid_data_dirs = []
    error_messages = []
    data_dirs_unmounted = set()
    for data_dir in params.dfs_data_dir.split(','):
        if ((data_dir is None) or (data_dir.strip() == '')):
            continue
        data_dir = data_dir.strip()
        valid_data_dirs.append(data_dir)
        if (not os.path.isdir(data_dir)):
            may_create_this_dir = allowed_to_create_any_dir
            last_mount_point_for_dir = None
            if (not may_create_this_dir):
                last_mount_point_for_dir = (prev_data_dir_to_mount_point[data_dir] if (data_dir in prev_data_dir_to_mount_point) else None)
                if (last_mount_point_for_dir is None):
                    may_create_this_dir = True
                else:
                    curr_mount_point = get_mount_point_for_dir(data_dir)
                    if ((last_mount_point_for_dir == '/') or ((curr_mount_point is not None) and (curr_mount_point != '/'))):
                        may_create_this_dir = True
            if may_create_this_dir:
                Logger.info('Forcefully creating directory: {0}'.format(data_dir))
                func(data_dir, params)
            elif (last_mount_point_for_dir is not None):
                data_dirs_unmounted.add(data_dir)
                msg = 'Directory {0} does not exist and became unmounted from {1} .'.format(data_dir, last_mount_point_for_dir)
                error_messages.append(msg)
    pass
    if update_cache:
        get_and_cache_mount_points(refresh=True)
    for data_dir in valid_data_dirs:
        if (os.path.isdir(data_dir) and (data_dir not in data_dirs_unmounted)):
            curr_mount_point = get_mount_point_for_dir(data_dir)
            data_dir_to_mount_point[data_dir] = curr_mount_point
            func(data_dir, params)
    if (error_messages and (len(error_messages) > 0)):
        header = ' ERROR '.join((['*****'] * 6))
        header = (('\n' + '\n'.join(([header] * 3))) + '\n')
        msg = (' '.join(error_messages) + ' Please remount the data dir(s) and run this command again. To ignore this failure and allow writing to the root partition, either update the contents of {0}, or delete that file.'.format(params.data_dir_mount_file))
        Logger.error(((header + msg) + header))
    data_dir_to_mount = DATA_DIR_TO_MOUNT_HEADER
    for kv in data_dir_to_mount_point.iteritems():
        data_dir_to_mount += (((kv[0] + ',') + kv[1]) + '\n')
    return data_dir_to_mount
