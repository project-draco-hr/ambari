{
  RepositoryVersionEntity targetRve=s_repoVersionDAO.findByStackNameAndVersion(stackName,version);
  if (null == targetRve) {
    LOG.info("Could not find version entity for {}; not setting new configs",version);
    return;
  }
  if (null == userName) {
    userName=getManagementController().getAuthName();
  }
  StackEntity targetStack=targetRve.getStack();
  StackId currentStackId=cluster.getCurrentStackVersion();
  StackId desiredStackId=cluster.getDesiredStackVersion();
  StackId targetStackId=new StackId(targetStack);
switch (direction) {
case UPGRADE:
    if (currentStackId.equals(targetStackId)) {
      return;
    }
  break;
case DOWNGRADE:
if (desiredStackId.equals(targetStackId)) {
  return;
}
break;
}
Map<String,Map<String,String>> updatedConfigurationsByType=null;
ConfigHelper configHelper=getManagementController().getConfigHelper();
if (direction == Direction.UPGRADE) {
Map<String,Set<PropertyInfo>> newConfigurationsByType=configHelper.getDefaultProperties(targetStackId,cluster);
Set<String> skipConfigTypes=new HashSet<String>();
Set<String> upgradePackServices=new HashSet<String>();
Set<String> upgradePackConfigTypes=new HashSet<String>();
AmbariMetaInfo ambariMetaInfo=s_metaProvider.get();
Map<String,ServiceInfo> stackServicesMap=ambariMetaInfo.getServices(targetStack.getStackName(),targetStack.getStackVersion());
for (Grouping group : upgradePack.getGroups(direction)) {
for (UpgradePack.OrderService service : group.services) {
if (service.serviceName == null || upgradePackServices.contains(service.serviceName)) {
  continue;
}
upgradePackServices.add(service.serviceName);
ServiceInfo serviceInfo=stackServicesMap.get(service.serviceName);
if (serviceInfo == null) {
  continue;
}
Set<String> serviceConfigTypes=serviceInfo.getConfigTypeAttributes().keySet();
for (String serviceConfigType : serviceConfigTypes) {
  if (!upgradePackConfigTypes.contains(serviceConfigType)) {
    upgradePackConfigTypes.add(serviceConfigType);
  }
}
}
}
Set<String> servicesNotInUpgradePack=new HashSet<String>(stackServicesMap.keySet());
servicesNotInUpgradePack.removeAll(upgradePackServices);
for (String serviceNotInUpgradePack : servicesNotInUpgradePack) {
ServiceInfo serviceInfo=stackServicesMap.get(serviceNotInUpgradePack);
Set<String> configTypesOfServiceNotInUpgradePack=serviceInfo.getConfigTypeAttributes().keySet();
for (String configType : configTypesOfServiceNotInUpgradePack) {
if (!upgradePackConfigTypes.contains(configType) && !skipConfigTypes.contains(configType)) {
  skipConfigTypes.add(configType);
}
}
}
Iterator<String> iterator=newConfigurationsByType.keySet().iterator();
while (iterator.hasNext()) {
String configType=iterator.next();
if (skipConfigTypes.contains(configType)) {
LOG.info("RU: Removing configs for config-type {}",configType);
iterator.remove();
}
}
Map<String,Map<String,String>> existingPropertiesByType=new HashMap<>();
Map<String,DesiredConfig> existingDesiredConfigurationsByType=cluster.getDesiredConfigs();
for (String configurationType : existingDesiredConfigurationsByType.keySet()) {
if (skipConfigTypes.contains(configurationType)) {
LOG.info("RU: Skipping config-configurationType {} as upgrade-pack contains no updates to its service",configurationType);
continue;
}
Map<String,String> existingProperties=cluster.getDesiredConfigByType(configurationType).getProperties();
existingPropertiesByType.put(configurationType,existingProperties);
}
for (Map.Entry<String,Set<PropertyInfo>> newPropertyEntry : newConfigurationsByType.entrySet()) {
String configurationType=newPropertyEntry.getKey();
Map<String,String> existingProperties=existingPropertiesByType.get(configurationType);
if (existingProperties == null) {
existingProperties=new HashMap<>();
existingPropertiesByType.put(configurationType,existingProperties);
}
for (PropertyInfo propertyInfo : newPropertyEntry.getValue()) {
String propertyName=propertyInfo.getName();
String propertyValue=propertyInfo.getValue();
PropertyUpgradeBehavior propertyStackUpgradeBehavior=propertyInfo.getPropertyStackUpgradeBehavior();
if (!existingProperties.containsKey(propertyName) && propertyStackUpgradeBehavior.isAdd()) {
  existingProperties.put(propertyName,propertyValue);
}
 else if (existingProperties.containsKey(propertyName)) {
  if (propertyStackUpgradeBehavior.isDelete()) {
    existingProperties.remove(propertyName);
  }
 else   if (propertyStackUpgradeBehavior.isChange()) {
    existingProperties.put(propertyName,propertyValue);
  }
}
}
}
updatedConfigurationsByType=existingPropertiesByType;
}
 else {
cluster.applyLatestConfigurations(cluster.getCurrentStackVersion());
}
cluster.setDesiredStackVersion(new StackId(targetStack.getStackName(),targetStack.getStackVersion()),true);
if (null != updatedConfigurationsByType) {
configHelper.createConfigTypes(cluster,getManagementController(),updatedConfigurationsByType,userName,"Configuration created for Upgrade");
}
}
