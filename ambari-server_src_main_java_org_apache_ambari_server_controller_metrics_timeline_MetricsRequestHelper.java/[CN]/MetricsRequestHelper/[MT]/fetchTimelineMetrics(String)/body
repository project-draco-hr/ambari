{
  LOG.debug("Metrics request url = " + spec);
  BufferedReader reader=null;
  TimelineMetrics timelineMetrics=null;
  try {
    HttpURLConnection connection=streamProvider.processURL(spec,HttpMethod.GET,(String)null,null);
    if (connection.getResponseCode() == HttpStatus.SC_BAD_REQUEST) {
      InputStream errorStream=connection.getErrorStream();
      reader=new BufferedReader(new InputStreamReader(errorStream));
      throw new IOException(reader.readLine());
    }
    InputStream inputStream=connection.getInputStream();
    reader=new BufferedReader(new InputStreamReader(inputStream));
    timelineMetrics=timelineObjectReader.readValue(reader);
    if (LOG.isTraceEnabled()) {
      for (      TimelineMetric metric : timelineMetrics.getMetrics()) {
        LOG.trace("metric: " + metric.getMetricName() + ", size = "+ metric.getMetricValues().size()+ ", host = "+ metric.getHostName()+ ", app = "+ metric.getAppId()+ ", instance = "+ metric.getInstanceId()+ ", time = "+ metric.getTimestamp()+ ", startTime = "+ new Date(metric.getStartTime()));
      }
    }
  }
 catch (  IOException io) {
    String errorMsg="Error getting timeline metrics : " + io.getMessage();
    LOG.error(errorMsg);
    if (LOG.isDebugEnabled()) {
      LOG.debug(errorMsg,io);
    }
    if (io instanceof SocketTimeoutException) {
      errorMsg+=" Can not connect to collector, socket error.";
      LOG.error(errorMsg);
      throw io;
    }
  }
 finally {
    if (reader != null) {
      try {
        reader.close();
      }
 catch (      IOException e) {
        if (LOG.isWarnEnabled()) {
          if (LOG.isDebugEnabled()) {
            LOG.warn("Unable to close http input stream : spec=" + spec,e);
          }
 else {
            LOG.warn("Unable to close http input stream : spec=" + spec);
          }
        }
      }
    }
  }
  return timelineMetrics;
}
