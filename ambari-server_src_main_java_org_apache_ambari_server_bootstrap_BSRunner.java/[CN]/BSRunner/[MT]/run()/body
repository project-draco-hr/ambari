{
  String hostString=createHostString(sshHostInfo.getHosts());
  String user=sshHostInfo.getUser();
  String userRunAs=sshHostInfo.getUserRunAs();
  if (user == null || user.isEmpty()) {
    user=DEFAULT_USER;
  }
  String command[]=new String[12];
  BSStat stat=BSStat.RUNNING;
  String scriptlog="";
  try {
    createRunDir();
    if (LOG.isDebugEnabled()) {
      LOG.debug("Using ssh key=\"" + sshHostInfo.getSshKey() + "\"");
    }
    String password=sshHostInfo.getPassword();
    if (password != null && !password.isEmpty()) {
      this.passwordFile=new File(this.requestIdDir,"host_pass");
      String lineSeparator=System.getProperty("line.separator");
      password=password + lineSeparator;
      writePasswordFile(password);
    }
    writeSshKeyFile(sshHostInfo.getSshKey());
    command[0]=this.bsScript;
    command[1]=hostString;
    command[2]=this.requestIdDir.toString();
    command[3]=user;
    command[4]=this.sshKeyFile.toString();
    command[5]=this.agentSetupScript.toString();
    command[6]=this.ambariHostname;
    command[7]=this.clusterOsFamily;
    command[8]=this.projectVersion;
    command[9]=this.serverPort + "";
    command[10]=userRunAs;
    command[11]=(this.passwordFile == null) ? "null" : this.passwordFile.toString();
    LOG.info("Host= " + hostString + " bs="+ this.bsScript+ " requestDir="+ requestIdDir+ " user="+ user+ " keyfile="+ this.sshKeyFile+ " passwordFile "+ this.passwordFile+ " server="+ this.ambariHostname+ " version="+ projectVersion+ " serverPort="+ this.serverPort+ " userRunAs="+ userRunAs);
    String[] env=new String[]{"AMBARI_PASSPHRASE=" + agentSetupPassword};
    if (this.verbose)     env=new String[]{env[0]," BS_VERBOSE=\"-vvv\" "};
    if (LOG.isDebugEnabled()) {
      LOG.debug(Arrays.toString(command));
    }
    String bootStrapOutputFilePath=requestIdDir + File.separator + "bootstrap.out";
    String bootStrapErrorFilePath=requestIdDir + File.separator + "bootstrap.err";
    Process process=Runtime.getRuntime().exec(command,env);
    PrintWriter stdOutWriter=null;
    PrintWriter stdErrWriter=null;
    try {
      stdOutWriter=new PrintWriter(bootStrapOutputFilePath);
      stdErrWriter=new PrintWriter(bootStrapErrorFilePath);
      IOUtils.copy(process.getInputStream(),stdOutWriter);
      IOUtils.copy(process.getErrorStream(),stdErrWriter);
    }
  finally {
      if (stdOutWriter != null)       stdOutWriter.close();
      if (stdErrWriter != null)       stdErrWriter.close();
    }
    ScheduledExecutorService scheduler=Executors.newScheduledThreadPool(1);
    BSStatusCollector statusCollector=new BSStatusCollector();
    ScheduledFuture<?> handle=scheduler.scheduleWithFixedDelay(statusCollector,0,10,TimeUnit.SECONDS);
    LOG.info("Kicking off the scheduler for polling on logs in " + this.requestIdDir);
    try {
      LOG.info("Bootstrap output, log=" + bootStrapErrorFilePath + " "+ bootStrapOutputFilePath);
      int exitCode=process.waitFor();
      String outMesg="";
      String errMesg="";
      try {
        outMesg=FileUtils.readFileToString(new File(bootStrapOutputFilePath));
        errMesg=FileUtils.readFileToString(new File(bootStrapErrorFilePath));
      }
 catch (      IOException io) {
        LOG.info("Error in reading files ",io);
      }
      scriptlog=outMesg + "\n\n" + errMesg;
      LOG.info("Script log Mesg " + scriptlog);
      if (exitCode != 0) {
        stat=BSStat.ERROR;
      }
 else {
        stat=BSStat.SUCCESS;
      }
      scheduler.schedule(new BSStatusCollector(),0,TimeUnit.SECONDS);
      long startTime=System.currentTimeMillis();
      while (true) {
        if (LOG.isDebugEnabled()) {
          LOG.debug("Waiting for hosts status to be updated");
        }
        boolean pendingHosts=false;
        BootStrapStatus tmpStatus=bsImpl.getStatus(requestId);
        List<BSHostStatus> hostStatusList=tmpStatus.getHostsStatus();
        if (hostStatusList != null) {
          for (          BSHostStatus status : hostStatusList) {
            if (status.getStatus().equals("RUNNING")) {
              pendingHosts=true;
            }
          }
        }
 else {
          pendingHosts=true;
        }
        if (LOG.isDebugEnabled()) {
          LOG.debug("Whether hosts status yet to be updated, pending=" + pendingHosts);
        }
        if (!pendingHosts) {
          break;
        }
        try {
          Thread.sleep(1000);
        }
 catch (        InterruptedException e) {
        }
        long now=System.currentTimeMillis();
        if (now >= (startTime + 15000)) {
          LOG.warn("Gave up waiting for hosts status to be updated");
          break;
        }
      }
    }
 catch (    InterruptedException e) {
      throw new IOException(e);
    }
 finally {
      handle.cancel(true);
      scheduler.schedule(new BSStatusCollector(),0,TimeUnit.SECONDS);
      scheduler.shutdownNow();
      try {
        scheduler.awaitTermination(10,TimeUnit.SECONDS);
      }
 catch (      InterruptedException e) {
        LOG.info("Interruped while waiting for scheduler");
      }
      process.destroy();
    }
  }
 catch (  IOException io) {
    LOG.info("Error executing bootstrap " + io.getMessage());
    stat=BSStat.ERROR;
  }
 finally {
    BootStrapStatus tmpStatus=bsImpl.getStatus(requestId);
    List<BSHostStatus> hostStatusList=tmpStatus.getHostsStatus();
    if (hostStatusList != null) {
      for (      BSHostStatus hostStatus : hostStatusList) {
        if ("FAILED".equals(hostStatus.getStatus())) {
          stat=BSStat.ERROR;
          break;
        }
      }
    }
 else {
      stat=BSStat.ERROR;
    }
    tmpStatus.setLog(scriptlog);
    tmpStatus.setStatus(stat);
    bsImpl.updateStatus(requestId,tmpStatus);
    bsImpl.reset();
    try {
      FileUtils.forceDelete(sshKeyFile);
    }
 catch (    IOException io) {
      LOG.warn(io.getMessage());
    }
    if (passwordFile != null) {
      try {
        FileUtils.forceDelete(passwordFile);
      }
 catch (      IOException io) {
        LOG.warn(io.getMessage());
      }
    }
    finished();
  }
}
