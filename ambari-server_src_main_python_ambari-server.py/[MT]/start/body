def start(args):
    if (not check_reverse_lookup()):
        print_warning_msg('The hostname was not found in the reverse DNS lookup. This may result in incorrect behavior. Please check the DNS setup and fix the issue.')
    current_user = getpass.getuser()
    ambari_user = read_ambari_user()
    if (ambari_user is None):
        err = ('Unable to detect a system user for Ambari Server.\n' + SETUP_OR_UPGRADE_MSG)
        raise FatalException(1, err)
    if ((current_user != ambari_user) and (not is_root())):
        err = 'Unable to start Ambari Server as user {0}. Please either run "ambari-server start" command as root, as sudo or as user "{1}"'.format(current_user, ambari_user)
        raise FatalException(1, err)
    check_database_name_property()
    parse_properties_file(args)
    update_debug_mode()
    (status, pid) = is_server_runing()
    if status:
        err = 'Ambari Server is already running.'
        raise FatalException(1, err)
    print_info_msg('Ambari Server is not running...')
    conf_dir = get_conf_dir()
    jdk_path = find_jdk()
    if (jdk_path is None):
        err = ('No JDK found, please run the "ambari-server setup" command to install a JDK automatically or install any JDK manually to ' + configDefaults.JDK_INSTALL_DIR)
        raise FatalException(1, err)
    if (args.persistence_type == 'remote'):
        result = find_jdbc_driver(args)
        msg = 'Before starting Ambari Server, you must copy the {0} JDBC driver JAR file to {1}.'.format(DATABASE_FULL_NAMES[args.dbms], configDefaults.JAVA_SHARE_PATH)
        if (result == (-1)):
            raise FatalException((-1), msg)
    if is_root():
        print "Ambari Server running with 'root' privileges."
        if (args.persistence_type == 'local'):
            (pg_status, retcode, out, err) = PGConfig._check_postgre_up()
            if (not (retcode == 0)):
                err = 'Unable to start PostgreSQL server. Status {0}. {1}. Exiting'.format(pg_status, err)
                raise FatalException(retcode, err)
    else:
        print 'Unable to check iptables status when starting without root privileges.'
        print 'Please do not forget to disable or adjust iptables if needed'
        if (args.persistence_type == 'local'):
            print 'Unable to check PostgreSQL server status when starting without root privileges.'
            print 'Please do not forget to start PostgreSQL server.'
    refresh_stack_hash()
    properties = get_ambari_properties()
    isSecure = get_is_secure(properties)
    (isPersisted, masterKeyFile) = get_is_persisted(properties)
    environ = os.environ.copy()
    if (isSecure and (not masterKeyFile)):
        prompt = False
        masterKey = environ.get(SECURITY_KEY_ENV_VAR_NAME)
        if ((masterKey is not None) and (masterKey != '')):
            pass
        else:
            keyLocation = environ.get(SECURITY_MASTER_KEY_LOCATION)
            if (keyLocation is not None):
                try:
                    with open(keyLocation, 'r'):
                        pass
                except IOError:
                    print_warning_msg('Cannot read Master key from path specified in environemnt.')
                    prompt = True
            else:
                prompt = True
        if prompt:
            import pwd
            masterKey = get_original_master_key(properties)
            tempDir = tempfile.gettempdir()
            tempFilePath = ((tempDir + os.sep) + 'masterkey')
            save_master_key(masterKey, tempFilePath, True)
            if (ambari_user != current_user):
                uid = pwd.getpwnam(ambari_user).pw_uid
                gid = pwd.getpwnam(ambari_user).pw_gid
                os.chown(tempFilePath, uid, gid)
            else:
                os.chmod(tempFilePath, (stat.S_IREAD | stat.S_IWRITE))
            if (tempFilePath is not None):
                environ[SECURITY_MASTER_KEY_LOCATION] = tempFilePath
    debug_mode = get_debug_mode()
    debug_start = ((debug_mode & 1) or SERVER_START_DEBUG)
    suspend_start = ('y' if ((debug_mode & 2) or SUSPEND_START_MODE) else 'n')
    pidfile = os.path.join(configDefaults.PID_DIR, PID_NAME)
    command_base = (SERVER_START_CMD_DEBUG if debug_start else SERVER_START_CMD)
    command = ('%s %s; %s' % (ULIMIT_CMD, str(get_ulimit_open_files()), command_base.format(get_java_exe_path(), conf_dir, get_ambari_classpath(), os.path.join(configDefaults.PID_DIR, EXITCODE_NAME), suspend_start)))
    if (not os.path.exists(configDefaults.PID_DIR)):
        os.makedirs(configDefaults.PID_DIR, 493)
    os.chdir(configDefaults.ROOT_FS_PATH)
    if (is_root() and (ambari_user != 'root')):
        param_list = [locate_file('su', '/bin'), ambari_user, '-s', locate_file('sh', '/bin'), '-c', command]
    else:
        param_list = [locate_file('sh', '/bin'), '-c', command]
    print_info_msg(('Running server: ' + str(param_list)))
    subprocess.Popen(param_list, env=environ)
    print ('Server PID at: ' + pidfile)
    print ('Server out at: ' + configDefaults.SERVER_OUT_FILE)
    print ('Server log at: ' + configDefaults.SERVER_LOG_FILE)
    sys.stdout.write('Waiting for server start...')
    sys.stdout.flush()
    pids = looking_for_pid(SERVER_SEARCH_PATTERN, SERVER_INIT_TIMEOUT)
    found_pids = wait_for_pid(pids, SERVER_START_TIMEOUT)
    sys.stdout.write('\n')
    sys.stdout.flush()
    if (found_pids <= 0):
        exitcode = check_exitcode(os.path.join(configDefaults.PID_DIR, EXITCODE_NAME))
        raise FatalException((-1), AMBARI_SERVER_DIE_MSG.format(exitcode, configDefaults.SERVER_OUT_FILE))
    else:
        save_main_pid_ex(pids, pidfile, [locate_file('sh', '/bin'), locate_file('bash', '/bin')], True)
