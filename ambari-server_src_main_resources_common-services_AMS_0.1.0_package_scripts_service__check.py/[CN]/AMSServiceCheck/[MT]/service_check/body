def service_check(self, env):
    import params
    Logger.info('AMS service check was started.')
    env.set_params(params)
    random_value1 = random.random()
    current_time = time.time()
    metric_json = Template('smoketest_metrics.json.j2', hostname=params.hostname, random1=random_value1, current_time=current_time).get_content()
    Logger.info(('Generated metrics:\n%s' % metric_json))
    headers = {'Content-type': 'application/json', }
    for i in xrange(1, self.AMS_CONNECT_TRIES):
        try:
            Logger.info(('Connecting (POST) to %s:%s%s' % (params.ams_collector_host_single, params.metric_collector_port, self.AMS_METRICS_POST_URL)))
            conn = httplib.HTTPConnection(params.ams_collector_host_single, int(params.metric_collector_port))
            conn.request('POST', self.AMS_METRICS_POST_URL, metric_json, headers)
            break
        except (httplib.HTTPException, socket.error) as ex:
            if (i < self.AMS_CONNECT_TRIES):
                time.sleep(self.AMS_CONNECT_TIMEOUT)
                Logger.info(('Connection failed. Next retry in %s seconds.' % self.AMS_CONNECT_TIMEOUT))
            else:
                Fail('AMS metrics were not saved. Service check has failed. \nConnection failed.')
    response = conn.getresponse()
    Logger.info(('Http response: %s %s' % (response.status, response.reason)))
    data = response.read()
    Logger.info(('Http data: %s' % data))
    conn.close()
    if (response.status == 200):
        Logger.info('AMS metrics were saved.')
    else:
        Logger.info('AMS metrics were not saved. Service check has failed.')
        raise Fail(('AMS metrics were not saved. Service check has failed. POST request status: %s %s \n%s' % (response.status, response.reason, data)))
    get_metrics_parameters = {'metricNames': 'AMS.SmokeTest.FakeMetric', 'appId': 'amssmoketestfake', 'hostname': params.hostname, 'startTime': 1419860000000, 'precision': 'seconds', 'grouped': 'false', }
    encoded_get_metrics_parameters = urllib.urlencode(get_metrics_parameters)
    Logger.info(('Connecting (GET) to %s:%s%s' % (params.ams_collector_host_single, params.metric_collector_port, (self.AMS_METRICS_GET_URL % encoded_get_metrics_parameters))))
    conn = httplib.HTTPConnection(params.ams_collector_host_single, int(params.metric_collector_port))
    conn.request('GET', (self.AMS_METRICS_GET_URL % encoded_get_metrics_parameters))
    response = conn.getresponse()
    Logger.info(('Http response: %s %s' % (response.status, response.reason)))
    data = response.read()
    Logger.info(('Http data: %s' % data))
    conn.close()
    if (response.status == 200):
        Logger.info('AMS metrics were retrieved.')
    else:
        Logger.info('AMS metrics were not retrieved. Service check has failed.')
        raise Fail(('AMS metrics were not retrieved. Service check has failed. GET request status: %s %s \n%s' % (response.status, response.reason, data)))
    data_json = json.loads(data)

    def floats_eq(f1, f2, delta):
        return (abs((f1 - f2)) < delta)
    for metrics_data in data_json['metrics']:
        if (floats_eq(metrics_data['metrics']['1419860001000'], random_value1, 1e-07) and floats_eq(metrics_data['metrics']['1419860002000'], current_time, 1)):
            Logger.info(('Values %s and %s were found in response.' % (random_value1, current_time)))
            break
        pass
    else:
        Logger.info(('Values %s and %s were not found in response.' % (random_value1, current_time)))
        raise Fail(('Values %s and %s were not found in response.' % (random_value1, current_time)))
    Logger.info('AMS service check is finished.')
