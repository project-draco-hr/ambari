def _make_web_request(self, url):
    '\n    Makes an http(s) request to a web resource and returns the http code. If\n    there was an error making the request, return 0 for the status code.\n    '
    error_msg = None
    try:
        response_code = 0
        kerberos_keytab = None
        kerberos_principal = None
        if (self.uri_property_keys.kerberos_principal is not None):
            kerberos_principal = self._get_configuration_value(self.uri_property_keys.kerberos_principal)
            if (kerberos_principal is not None):
                kerberos_principal = kerberos_principal.replace('_HOST', self.host_name)
        if (self.uri_property_keys.kerberos_keytab is not None):
            kerberos_keytab = self._get_configuration_value(self.uri_property_keys.kerberos_keytab)
        if ((kerberos_principal is not None) and (kerberos_keytab is not None)):
            tmp_dir = self.config.get('agent', 'tmp_dir')
            if (tmp_dir is None):
                tmp_dir = gettempdir()
            ccache_file_name = _md5('{0}|{1}'.format(kerberos_principal, kerberos_keytab)).hexdigest()
            ccache_file_path = '{0}{1}web_alert_cc_{2}'.format(tmp_dir, os.sep, ccache_file_name)
            kerberos_env = {'KRB5CCNAME': ccache_file_path, }
            kerberos_executable_search_paths = self._get_configuration_value('{{kerberos-env/executable_search_paths}}')
            klist_path_local = get_klist_path(kerberos_executable_search_paths)
            if (os.system('{0} -s {1}'.format(klist_path_local, ccache_file_path)) != 0):
                kinit_path_local = get_kinit_path(kerberos_executable_search_paths)
                logger.debug('[Alert][{0}] Enabling Kerberos authentication via GSSAPI using ccache at {1}.'.format(self.get_name(), ccache_file_path))
                os.system('{0} -l 5m -c {1} -kt {2} {3} > /dev/null'.format(kinit_path_local, ccache_file_path, kerberos_keytab, kerberos_principal))
            else:
                logger.debug('[Alert][{0}] Kerberos authentication via GSSAPI already enabled using ccache at {1}.'.format(self.get_name(), ccache_file_path))
            tmp_dir = self.config.get('agent', 'tmp_dir')
            cookies_dir = os.path.join(tmp_dir, 'cookies')
            if (not os.path.exists(cookies_dir)):
                os.makedirs(cookies_dir)
            cookie_file_name = str(uuid.uuid4())
            cookie_file = os.path.join(cookies_dir, cookie_file_name)
            start_time = time.time()
            try:
                curl = subprocess.Popen(['curl', '--negotiate', '-u', ':', '-b', cookie_file, '-c', cookie_file, '-sL', '-w', '%{http_code}', url, '--connect-timeout', CURL_CONNECTION_TIMEOUT, '-o', '/dev/null'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=kerberos_env)
                (curl_stdout, curl_stderr) = curl.communicate()
            finally:
                if os.path.isfile(cookie_file):
                    os.remove(cookie_file)
            if curl_stderr:
                error_msg = curl_stderr
            if curl_stdout:
                response_code = int(curl_stdout)
            time_millis = (time.time() - start_time)
        else:
            (response_code, time_millis, error_msg) = self._make_web_request_urllib(url)
        return WebResponse(status_code=response_code, time_millis=time_millis, error_msg=error_msg)
    except Exception as exception:
        if logger.isEnabledFor(logging.DEBUG):
            logger.exception('[Alert][{0}] Unable to make a web request.'.format(self.get_name()))
        return WebResponse(status_code=0, time_millis=0, error_msg=str(exception))
