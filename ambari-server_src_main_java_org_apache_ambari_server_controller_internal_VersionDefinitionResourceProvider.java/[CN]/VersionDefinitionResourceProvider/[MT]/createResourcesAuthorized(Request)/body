{
  Set<Map<String,Object>> requestProperties=request.getProperties();
  if (requestProperties.size() > 1) {
    throw new IllegalArgumentException("Cannot process more than one file per request");
  }
  final Map<String,Object> properties=requestProperties.iterator().next();
  if (!properties.containsKey(VERSION_DEF_DEFINITION_URL) && !properties.containsKey(VERSION_DEF_DEFINITION_BASE64) && !properties.containsKey(VERSION_DEF_AVAILABLE_DEFINITION)) {
    throw new IllegalArgumentException(String.format("Creation method is not known.  %s or %s is required or upload the file directly",VERSION_DEF_DEFINITION_URL,VERSION_DEF_AVAILABLE_DEFINITION));
  }
  if (properties.containsKey(VERSION_DEF_DEFINITION_URL) && properties.containsKey(VERSION_DEF_DEFINITION_BASE64)) {
    throw new IllegalArgumentException(String.format("Specify ONLY the url with %s or upload the file directly",VERSION_DEF_DEFINITION_URL));
  }
  final String definitionUrl=(String)properties.get(VERSION_DEF_DEFINITION_URL);
  final String definitionBase64=(String)properties.get(VERSION_DEF_DEFINITION_BASE64);
  final String definitionName=(String)properties.get(VERSION_DEF_AVAILABLE_DEFINITION);
  final boolean dryRun=request.isDryRunRequest();
  XmlHolder xmlHolder=createResources(new Command<XmlHolder>(){
    @Override public XmlHolder invoke() throws AmbariException {
      XmlHolder holder=null;
      if (null != definitionUrl) {
        holder=loadXml(definitionUrl);
      }
 else       if (null != definitionBase64) {
        holder=loadXml(Base64.decodeBase64(definitionBase64));
      }
 else       if (null != definitionName) {
        VersionDefinitionXml xml=s_metaInfo.get().getVersionDefinition(definitionName);
        if (null == xml) {
          throw new AmbariException(String.format("Version %s not found",definitionName));
        }
        holder=new XmlHolder();
        holder.xml=xml;
        try {
          holder.xmlString=xml.toXml();
        }
 catch (        Exception e) {
          throw new AmbariException(String.format("The available repository %s does not serialize",definitionName));
        }
      }
 else {
        throw new AmbariException("Cannot determine creation method");
      }
      toRepositoryVersionEntity(holder);
      if (!dryRun) {
        RepositoryVersionResourceProvider.validateRepositoryVersion(s_repoVersionDAO,s_metaInfo.get(),holder.entity);
      }
      checkForParent(holder);
      if (!dryRun) {
        s_repoVersionDAO.create(holder.entity);
      }
      return holder;
    }
  }
);
  final Resource res;
  if (dryRun) {
    Set<String> ids=Sets.newHashSet(VERSION_DEF_TYPE_PROPERTY_ID,VERSION_DEF_FULL_VERSION,VERSION_DEF_RELEASE_BUILD,VERSION_DEF_RELEASE_COMPATIBLE_WITH,VERSION_DEF_RELEASE_NOTES,VERSION_DEF_RELEASE_VERSION,VERSION_DEF_AVAILABLE_SERVICES,VERSION_DEF_STACK_SERVICES);
    boolean fromAvailable=null != definitionName;
    res=toResource(null,xmlHolder.xml,ids,fromAvailable);
    addSubresources(res,xmlHolder.entity);
  }
 else {
    res=toResource(xmlHolder.entity,Collections.<String>emptySet());
    notifyCreate(Resource.Type.VersionDefinition,request);
  }
  RequestStatusImpl status=new RequestStatusImpl(null,Collections.singleton(res));
  return status;
}
