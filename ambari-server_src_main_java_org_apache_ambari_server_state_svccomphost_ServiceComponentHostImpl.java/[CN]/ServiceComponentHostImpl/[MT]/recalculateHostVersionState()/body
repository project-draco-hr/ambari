{
  final String version=getVersion();
  if (version.equals("UNKNOWN")) {
    return null;
  }
  final String hostName=getHostName();
  final HostEntity host=hostDAO.findByName(hostName);
  final Set<Cluster> clustersForHost=clusters.getClustersForHost(hostName);
  if (clustersForHost.size() != 1) {
    throw new AmbariException("Host " + hostName + " should be assigned only to one cluster");
  }
  final Cluster cluster=clustersForHost.iterator().next();
  final StackId stack=cluster.getDesiredStackVersion();
  final StackInfo stackInfo=ambariMetaInfo.getStack(stack.getStackName(),stack.getStackVersion());
  RepositoryVersionEntity repositoryVersion=repositoryVersionDAO.findByStackAndVersion(stack.getStackId(),version);
  if (repositoryVersion == null) {
    LOG.info("Creating new repository version " + stack.getStackName() + "-"+ version);
    repositoryVersion=repositoryVersionDAO.create(stack.getStackId(),version,stack.getStackName() + "-" + version,repositoryVersionHelper.getUpgradePackageNameSafe(stack.getStackName(),stack.getStackVersion(),version),repositoryVersionHelper.serializeOperatingSystems(stackInfo.getRepositories()));
  }
  HostVersionEntity hostVersionEntity=null;
  List<HostVersionEntity> hostVersions=hostVersionDAO.findByHost(hostName);
  if (hostVersions == null || hostVersions.isEmpty()) {
    hostVersionEntity=new HostVersionEntity(hostName,repositoryVersion,RepositoryVersionState.UPGRADING);
    hostVersionEntity.setHostEntity(host);
    hostVersionDAO.create(hostVersionEntity);
  }
 else {
    hostVersionEntity=hostVersionDAO.findByClusterStackVersionAndHost(cluster.getClusterName(),repositoryVersion.getStack(),repositoryVersion.getVersion(),hostName);
    if (hostVersionEntity == null) {
      throw new AmbariException("Host " + hostName + " is expected to have a Host Version for stack "+ stack.getStackId());
    }
  }
  final Collection<HostComponentStateEntity> allHostComponents=host.getHostComponentStateEntities();
  final Collection<HostComponentStateEntity> versionedHostComponents=new HashSet<HostComponentStateEntity>();
  for (  HostComponentStateEntity hostComponentStateEntity : allHostComponents) {
    if (!hostComponentStateEntity.getVersion().equalsIgnoreCase("UNKNOWN")) {
      versionedHostComponents.add(hostComponentStateEntity);
    }
  }
  final Collection<HostComponentStateEntity> noVersionNeededComponents=new HashSet<HostComponentStateEntity>();
  final Collection<HostComponentStateEntity> nonVersionedHostComponents=CollectionUtils.subtract(allHostComponents,versionedHostComponents);
  for (  HostComponentStateEntity hostComponentStateEntity : nonVersionedHostComponents) {
    ComponentInfo compInfo=ambariMetaInfo.getComponent(stack.getStackName(),stack.getStackVersion(),hostComponentStateEntity.getServiceName(),hostComponentStateEntity.getComponentName());
    if (!compInfo.isAdvertiseVersion()) {
      noVersionNeededComponents.add(hostComponentStateEntity);
    }
  }
  List<ClusterVersionEntity> clusterVersions=clusterVersionDAO.findByCluster(cluster.getClusterName());
  final int versionedPlusNoVersionNeededSize=versionedHostComponents.size() + noVersionNeededComponents.size();
  if (clusterVersions.size() <= 1) {
    if (allHostComponents.size() == versionedPlusNoVersionNeededSize && (hostVersionEntity.getState().equals(RepositoryVersionState.UPGRADING) || hostVersionEntity.getState().equals(RepositoryVersionState.UPGRADED)) && haveSameVersion(versionedHostComponents)) {
      hostVersionEntity.setState(RepositoryVersionState.CURRENT);
      hostVersionDAO.merge(hostVersionEntity);
    }
  }
 else {
    if (allHostComponents.size() == versionedPlusNoVersionNeededSize && hostVersionEntity.getState().equals(RepositoryVersionState.UPGRADING) && haveSameVersion(versionedHostComponents)) {
      hostVersionEntity.setState(RepositoryVersionState.UPGRADED);
      hostVersionDAO.merge(hostVersionEntity);
    }
 else {
      if (hostVersionEntity.getState().equals(RepositoryVersionState.INSTALLED) && versionedHostComponents.size() > 0 && !haveSameVersion(versionedHostComponents)) {
        hostVersionEntity.setState(RepositoryVersionState.UPGRADING);
        hostVersionDAO.merge(hostVersionEntity);
      }
    }
  }
  return version;
}
