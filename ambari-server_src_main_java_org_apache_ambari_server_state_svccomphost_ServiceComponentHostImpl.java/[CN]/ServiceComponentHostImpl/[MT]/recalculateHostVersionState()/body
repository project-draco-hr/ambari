{
  final String version=getVersion();
  if (version.equals("UNKNOWN")) {
    return;
  }
  final String hostName=getHostName();
  final HostEntity host=hostDAO.findByName(hostName);
  final Set<Cluster> clustersForHost=clusters.getClustersForHost(hostName);
  if (clustersForHost.size() != 1) {
    throw new AmbariException("Host " + hostName + " should be assigned only to one cluster");
  }
  final Cluster cluster=clustersForHost.iterator().next();
  final StackId stack=cluster.getDesiredStackVersion();
  final StackInfo stackInfo=ambariMetaInfo.getStack(stack.getStackName(),stack.getStackVersion());
  RepositoryVersionEntity repositoryVersion=repositoryVersionDAO.findByStackAndVersion(stack.getStackId(),version);
  if (repositoryVersion == null) {
    LOG.info("Creating new repository version " + stack.getStackName() + "-"+ version);
    repositoryVersion=repositoryVersionDAO.create(stack.getStackId(),version,stack.getStackName() + "-" + version,repositoryVersionHelper.getUpgradePackageNameSafe(stack.getStackName(),stack.getStackVersion(),version),repositoryVersionHelper.serializeOperatingSystems(stackInfo.getRepositories()));
  }
  HostVersionEntity hostVersionEntity=hostVersionDAO.findByClusterStackVersionAndHost(cluster.getClusterName(),repositoryVersion.getStack(),repositoryVersion.getVersion(),hostName);
  if (hostVersionEntity == null) {
    hostVersionEntity=new HostVersionEntity(hostName,repositoryVersion,RepositoryVersionState.UPGRADING);
    hostVersionEntity.setHostEntity(host);
    hostVersionDAO.create(hostVersionEntity);
  }
  final Collection<HostComponentStateEntity> allHostComponents=host.getHostComponentStateEntities();
  final Collection<HostComponentStateEntity> upgradedHostComponents=new HashSet<HostComponentStateEntity>();
  final Collection<HostComponentStateEntity> versionedHostComponents=new HashSet<HostComponentStateEntity>();
  for (  HostComponentStateEntity hostComponentStateEntity : allHostComponents) {
    if (!hostComponentStateEntity.getVersion().equals("UNKNOWN")) {
      versionedHostComponents.add(hostComponentStateEntity);
      if (hostComponentStateEntity.getUpgradeState().equals(UpgradeState.COMPLETE)) {
        upgradedHostComponents.add(hostComponentStateEntity);
      }
    }
  }
  @SuppressWarnings("unchecked") final Collection<HostComponentStateEntity> nonUpgradedHostComponents=CollectionUtils.subtract(allHostComponents,upgradedHostComponents);
  for (  HostComponentStateEntity hostComponentStateEntity : nonUpgradedHostComponents) {
    if (hostComponentStateEntity.getComponentName().equalsIgnoreCase("ZKFC")) {
      upgradedHostComponents.add(hostComponentStateEntity);
    }
  }
  if (allHostComponents.size() == upgradedHostComponents.size() && haveSameVersion(upgradedHostComponents) && (hostVersionEntity.getState().equals(RepositoryVersionState.INSTALLED) || hostVersionEntity.getState().equals(RepositoryVersionState.UPGRADING))) {
    hostVersionEntity.setState(RepositoryVersionState.UPGRADED);
    hostVersionDAO.merge(hostVersionEntity);
  }
 else   if (allHostComponents.size() == versionedHostComponents.size() && haveSameVersion(versionedHostComponents) && hostVersionDAO.findByHostAndStateCurrent(cluster.getClusterName(),hostName) == null) {
    hostVersionEntity.setState(RepositoryVersionState.CURRENT);
    hostVersionDAO.merge(hostVersionEntity);
  }
 else   if (!upgradedHostComponents.isEmpty() && upgradedHostComponents.size() < allHostComponents.size()) {
    hostVersionEntity.setState(RepositoryVersionState.UPGRADING);
    hostVersionDAO.merge(hostVersionEntity);
  }
  cluster.recalculateClusterVersionState(version);
}
