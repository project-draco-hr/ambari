{
  final String version=getVersion();
  final String hostName=getHostName();
  final HostEntity host=hostDAO.findByName(hostName);
  final Set<Cluster> clustersForHost=clusters.getClustersForHost(hostName);
  if (clustersForHost.size() != 1) {
    throw new AmbariException("Host " + hostName + " should be assigned only to one cluster");
  }
  final Cluster cluster=clustersForHost.iterator().next();
  final StackId stack=cluster.getDesiredStackVersion();
  final RepositoryVersionEntity repositoryVersion=repositoryVersionDAO.findByStackAndVersion(stack.getStackId(),version);
  if (repositoryVersion == null) {
    LOG.debug("Repository version for stack " + stack.getStackId() + " for version "+ version+ " was not found");
    return;
  }
  final HostVersionEntity hostVersionEntity=hostVersionDAO.findByClusterStackVersionAndHost(cluster.getClusterName(),repositoryVersion.getStack(),repositoryVersion.getVersion(),hostName);
  if (hostVersionEntity == null) {
    LOG.debug(String.format("Host version version for host %s on cluster %s with stack %s and repository version %s was not found",hostName,cluster.getClusterName(),repositoryVersion.getStack(),repositoryVersion.getVersion()));
    return;
  }
  final Collection<HostComponentStateEntity> allHostComponents=host.getHostComponentStateEntities();
  final Collection<HostComponentStateEntity> upgradedHostComponents=new HashSet<HostComponentStateEntity>();
  for (  HostComponentStateEntity hostComponentStateEntity : allHostComponents) {
    if (hostComponentStateEntity.getUpgradeState().equals(UpgradeState.COMPLETE) && !hostComponentStateEntity.getVersion().equals("UNKNOWN")) {
      upgradedHostComponents.add(hostComponentStateEntity);
    }
  }
  final Collection<HostComponentStateEntity> nonUpgradedHostComponents=CollectionUtils.subtract(allHostComponents,upgradedHostComponents);
  for (  HostComponentStateEntity hostComponentStateEntity : nonUpgradedHostComponents) {
    if (hostComponentStateEntity.getComponentName().equalsIgnoreCase("ZKFC")) {
      upgradedHostComponents.add(hostComponentStateEntity);
    }
  }
  if (allHostComponents.size() == upgradedHostComponents.size() && (hostVersionEntity.getState().equals(RepositoryVersionState.INSTALLED) || hostVersionEntity.getState().equals(RepositoryVersionState.UPGRADING))) {
    hostVersionEntity.setState(RepositoryVersionState.UPGRADED);
    hostVersionDAO.merge(hostVersionEntity);
  }
  if (!upgradedHostComponents.isEmpty() && upgradedHostComponents.size() < allHostComponents.size()) {
    hostVersionEntity.setState(RepositoryVersionState.UPGRADING);
    hostVersionDAO.merge(hostVersionEntity);
  }
  cluster.recalculateClusterVersionState(version);
}
