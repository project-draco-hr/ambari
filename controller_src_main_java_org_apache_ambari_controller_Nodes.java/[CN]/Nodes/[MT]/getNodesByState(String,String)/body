{
  Boolean allocated=true;
  Boolean alive=true;
  if (allocatedx.equalsIgnoreCase("false")) {
    allocated=false;
  }
  if (alivex.equalsIgnoreCase("false")) {
    alive=false;
  }
  List<Node> list=new ArrayList<Node>();
  GregorianCalendar cal=new GregorianCalendar();
  cal.setTime(new Date());
  XMLGregorianCalendar curTime=DatatypeFactory.newInstance().newXMLGregorianCalendar(cal);
  for (  Node n : this.nodes.values()) {
    if (allocatedx.equals("") && alivex.equals("")) {
      list.add(n);
      continue;
    }
    if (allocatedx.equals("") && alive) {
      if (getTimeDiffInMillis(curTime,n.getNodeState().getLastHeartbeatTime()) < NODE_NOT_RESPONDING_DURATION) {
        list.add(n);
        continue;
      }
    }
    if (allocatedx.equals("") && !alive) {
      if (getTimeDiffInMillis(curTime,n.getNodeState().getLastHeartbeatTime()) >= NODE_NOT_RESPONDING_DURATION) {
        list.add(n);
        continue;
      }
    }
    if (alivex.equals("") && allocated) {
      if (n.getNodeState().getAllocatedToCluster()) {
        list.add(n);
        continue;
      }
    }
    if (alivex.equals("") && !allocated) {
      if (!n.getNodeState().getAllocatedToCluster()) {
        list.add(n);
        continue;
      }
    }
    if (allocated && alive) {
      if (n.getNodeState().getAllocatedToCluster() && getTimeDiffInMillis(curTime,n.getNodeState().getLastHeartbeatTime()) < NODE_NOT_RESPONDING_DURATION) {
        list.add(n);
        continue;
      }
    }
    if (allocated && !alive) {
      if (n.getNodeState().getAllocatedToCluster() && getTimeDiffInMillis(curTime,n.getNodeState().getLastHeartbeatTime()) >= NODE_NOT_RESPONDING_DURATION) {
        list.add(n);
        continue;
      }
    }
    if (!allocated && alive) {
      if (!n.getNodeState().getAllocatedToCluster() && getTimeDiffInMillis(curTime,n.getNodeState().getLastHeartbeatTime()) < NODE_NOT_RESPONDING_DURATION) {
        list.add(n);
        continue;
      }
    }
    if (!allocated && !alive) {
      if (!n.getNodeState().getAllocatedToCluster() && getTimeDiffInMillis(curTime,n.getNodeState().getLastHeartbeatTime()) >= NODE_NOT_RESPONDING_DURATION) {
        list.add(n);
        continue;
      }
    }
  }
  return list;
}
