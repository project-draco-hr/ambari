{
  Map<String,RoleStats> roleStats=initRoleStats(s);
  long now=System.currentTimeMillis();
  long taskTimeout=actionTimeout;
  if (taskTimeoutAdjustment) {
    taskTimeout=actionTimeout + s.getStageTimeout();
  }
  for (  String host : s.getHosts()) {
    List<ExecutionCommandWrapper> commandWrappers=s.getExecutionCommands(host);
    Cluster cluster=fsmObject.getCluster(s.getClusterName());
    Host hostObj=fsmObject.getHost(host);
    for (    ExecutionCommandWrapper wrapper : commandWrappers) {
      ExecutionCommand c=wrapper.getExecutionCommand();
      String roleStr=c.getRole();
      HostRoleStatus status=s.getHostRoleStatus(host,roleStr);
      if (timeOutActionNeeded(status,s,hostObj,roleStr,now,taskTimeout)) {
        LOG.info("Host:" + host + ", role:"+ roleStr+ ", actionId:"+ s.getActionId()+ " timed out");
        if (s.getAttemptCount(host,roleStr) >= maxAttempts) {
          LOG.warn("Host:" + host + ", role:"+ roleStr+ ", actionId:"+ s.getActionId()+ " expired");
          db.timeoutHostRole(host,s.getRequestId(),s.getStageId(),c.getRole());
          status=s.getHostRoleStatus(host,roleStr);
          transitionToFailedState(cluster.getClusterName(),c.getServiceName(),roleStr,host,now,false);
          LOG.warn("Operation timed out. Role: " + roleStr + ", host: "+ host);
          actionQueue.dequeue(host,c.getCommandId());
        }
 else {
          commandsToSchedule.add(c);
        }
      }
 else       if (status.equals(HostRoleStatus.PENDING)) {
        commandsToSchedule.add(c);
      }
      this.updateRoleStats(status,roleStats.get(roleStr));
    }
  }
  return roleStats;
}
