{
  for (  String host : hrcMap.keySet()) {
    HostRoleCommand hrc=hrcMap.get(host);
    if ((hrc.getStatus() != HostRoleStatus.PENDING) && (hrc.getStatus() != HostRoleStatus.QUEUED)) {
      continue;
    }
    long now=System.currentTimeMillis();
    if (now > hrc.getLastAttemptTime() + actionTimeout) {
      LOG.info("Host:" + host + ", role:"+ hrc.getRole()+ ", actionId:"+ stage.getActionId()+ " timed out");
      if (hrc.getAttemptCount() >= maxAttempts) {
        LOG.warn("Host:" + host + ", role:"+ hrc.getRole()+ ", actionId:"+ stage.getActionId()+ " expired");
        ServiceComponentHostEvent timeoutEvent=new ServiceComponentHostEvent(ServiceComponentHostEventType.HOST_SVCCOMP_OP_FAILED,hrc.getRole().toString(),hrc.getHostName(),now);
        try {
          fsmObject.getCluster(stage.getClusterName()).handleServiceComponentHostEvent("",hrc.getRole().toString(),hrc.getHostName(),timeoutEvent);
        }
 catch (        InvalidStateTransitonException e) {
          e.printStackTrace();
        }
        db.timeoutHostRole(stage.getRequestId(),stage.getStageId(),hrc.getRole());
      }
 else {
        scheduleHostRole(stage,hrc);
      }
    }
  }
}
