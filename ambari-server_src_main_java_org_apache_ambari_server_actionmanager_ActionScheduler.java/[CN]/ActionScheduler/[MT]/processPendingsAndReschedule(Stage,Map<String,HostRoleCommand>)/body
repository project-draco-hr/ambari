{
  LOG.info("Processing pending and queued actions");
  for (  String host : hrcMap.keySet()) {
    HostRoleCommand hrc=hrcMap.get(host);
    if ((hrc.getStatus() != HostRoleStatus.PENDING) && (hrc.getStatus() != HostRoleStatus.QUEUED)) {
      continue;
    }
    long now=System.currentTimeMillis();
    LOG.info("Last attempt time =" + stage.getLastAttemptTime(host) + ", actiontimeout ="+ this.actionTimeout+ ", current time="+ now);
    if (now > stage.getLastAttemptTime(host) + actionTimeout) {
      LOG.info("Host:" + host + ", role:"+ hrc.getRole()+ ", actionId:"+ stage.getActionId()+ " timed out");
      if (stage.getAttemptCount(host) >= maxAttempts) {
        LOG.warn("Host:" + host + ", role:"+ hrc.getRole()+ ", actionId:"+ stage.getActionId()+ " expired");
        ServiceComponentHostOpFailedEvent timeoutEvent=new ServiceComponentHostOpFailedEvent(hrc.getRole().toString(),host,now);
        try {
          Cluster c=fsmObject.getCluster(stage.getClusterName());
          Service svc=c.getService(hrc.getServiceName());
          ServiceComponent svcComp=svc.getServiceComponent(hrc.getRole().toString());
          ServiceComponentHost svcCompHost=svcComp.getServiceComponentHost(host);
          svcCompHost.handleEvent(timeoutEvent);
        }
 catch (        InvalidStateTransitonException e) {
          LOG.info("Transition failed for host: " + host + ", role: "+ hrc.getRole(),e);
        }
        db.timeoutHostRole(host,stage.getRequestId(),stage.getStageId(),hrc.getRole());
      }
 else {
        try {
          scheduleHostRole(stage,host,hrc);
        }
 catch (        InvalidStateTransitonException ex) {
          LOG.info("Cannot make this transition..aborting host role",ex);
          db.abortHostRole(host,stage.getRequestId(),stage.getStageId(),hrc.getRole());
        }
      }
    }
  }
}
