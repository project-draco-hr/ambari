{
  final StackInfo stackInfo=ambariMetaInfo.getStack(repositoryVersion.getStack(),repositoryVersion.getVersion());
  if (stackInfo == null) {
    throw new AmbariException("Stack " + repositoryVersion.getStack() + " "+ repositoryVersion.getVersion()+ " is not found");
  }
  final UpgradePack upgradePack=stackInfo.getUpgradePacks().get(repositoryVersion.getUpgradePackage());
  if (upgradePack == null) {
    throw new AmbariException("Upgrade pack " + repositoryVersion.getUpgradePackage() + " is not available for stack "+ repositoryVersion.getStack()+ " "+ repositoryVersion.getVersion());
  }
  final Set<String> osSupported=new HashSet<String>();
  for (  OperatingSystemInfo osInfo : ambariMetaInfo.getOperatingSystems(repositoryVersion.getStack(),repositoryVersion.getVersion())) {
    osSupported.add(osInfo.getOsType());
  }
  final Set<String> osRepositoryVersion=new HashSet<String>();
  final Matcher osMatcher=Pattern.compile("\"os\":\\s*\"(.+)\"").matcher(new Gson().fromJson(repositoryVersion.getRepositories(),Object.class).toString());
  while (osMatcher.find()) {
    osRepositoryVersion.add(osMatcher.group(1));
  }
  if (osRepositoryVersion.isEmpty()) {
    throw new AmbariException("At least one set of repositories for OS should be provided");
  }
  for (  String os : osRepositoryVersion) {
    if (!osSupported.contains(os)) {
      throw new AmbariException("Operating system type " + os + " is not supported by stack "+ repositoryVersion.getStack()+ " "+ repositoryVersion.getVersion());
    }
  }
  String regexPattern=upgradePack.getTarget();
  regexPattern=regexPattern.replaceAll("\\.","\\\\.");
  regexPattern=regexPattern.replaceAll("\\*","\\\\d+");
  regexPattern=regexPattern.concat("(-\\d+)?");
  if (!Pattern.matches(regexPattern,repositoryVersion.getVersion())) {
    throw new AmbariException("Upgrade pack " + repositoryVersion.getUpgradePackage() + " can't be applied to stack "+ repositoryVersion.getStack()+ " "+ repositoryVersion.getVersion());
  }
}
