@patch.object(urllib2, 'urlopen')
@patch('__builtin__.open')
@patch.object(os, 'makedirs')
@patch.object(os.path, 'exists')
def test_download_source_get_content_cache_existent_md5_unmatch(self, exists_mock, makedirs_mock, open_mock, urlopen_mock):
    '\n    Testing DownloadSource.get_content with cache on cached resource with md5 check\n    '
    exists_mock.side_effect = [True, True, False]
    fake_md5 = '144c9defac04969c7bfad8efaa8ea194'
    file_mock = MagicMock(name='file_mock')
    file_mock.__enter__.return_value = file_mock
    file_mock.read.return_value = 'cached_content'
    open_mock.return_value = file_mock
    web_file_mock = MagicMock()
    web_file_mock.read.return_value = 'web_content'
    urlopen_mock.return_value = web_file_mock
    with Environment('/base') as env:
        download_source = DownloadSource('http://download/source', cache=True, md5sum=fake_md5)
    content = download_source.get_content()
    self.assertEqual('web_content', content)
    self.assertEqual(open_mock.call_count, 2)
    open_mock.assert_once_called('/var/tmp/downloads/source', 'w')
    open_mock.assert_once_called('/var/tmp/downloads/source')
    self.assertEqual(file_mock.read.call_count, 1)
    self.assertEqual(urlopen_mock.call_count, 1)
    urlopen_mock.assert_called_with('http://download/source')
