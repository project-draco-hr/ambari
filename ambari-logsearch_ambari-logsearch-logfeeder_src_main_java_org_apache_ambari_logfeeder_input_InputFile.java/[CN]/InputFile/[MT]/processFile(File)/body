{
  logger.info("Monitoring logPath=" + logPath + ", logPathFile="+ logPathFile);
  BufferedReader br=null;
  checkPointFile=null;
  checkPointWriter=null;
  jsonCheckPoint=null;
  int resumeFromLineNumber=0;
  int lineCount=0;
  try {
    setFilePath(logPathFile.getAbsolutePath());
    br=new BufferedReader(LogsearchReaderFactory.INSTANCE.getReader(logPathFile));
    boolean resume=isStartFromBegining;
    fileKey=getFileKey(logPathFile);
    base64FileKey=Base64.byteArrayToBase64(fileKey.toString().getBytes());
    logger.info("fileKey=" + fileKey + ", base64="+ base64FileKey+ ". "+ getShortDescription());
    if (isTail()) {
      try {
        logger.info("Checking existing checkpoint file. " + getShortDescription());
        String fileBase64=Base64.byteArrayToBase64(fileKey.toString().getBytes());
        String checkPointFileName=fileBase64 + checkPointExtension;
        File checkPointFolder=inputMgr.getCheckPointFolderFile();
        checkPointFile=new File(checkPointFolder,checkPointFileName);
        checkPointWriter=new RandomAccessFile(checkPointFile,"rw");
        try {
          int contentSize=checkPointWriter.readInt();
          byte b[]=new byte[contentSize];
          int readSize=checkPointWriter.read(b,0,contentSize);
          if (readSize != contentSize) {
            logger.error("Couldn't read expected number of bytes from checkpoint file. expected=" + contentSize + ", read="+ readSize+ ", checkPointFile="+ checkPointFile+ ", input="+ getShortDescription());
          }
 else {
            String jsonCheckPointStr=new String(b,0,readSize);
            jsonCheckPoint=LogFeederUtil.toJSONObject(jsonCheckPointStr);
            resumeFromLineNumber=LogFeederUtil.objectToInt(jsonCheckPoint.get("line_number"),0,"line_number");
            if (resumeFromLineNumber > 0) {
              resume=false;
            }
            logger.info("CheckPoint. checkPointFile=" + checkPointFile + ", json="+ jsonCheckPointStr+ ", resumeFromLineNumber="+ resumeFromLineNumber+ ", resume="+ resume);
          }
        }
 catch (        EOFException eofEx) {
          logger.info("EOFException. Will reset checkpoint file " + checkPointFile.getAbsolutePath() + " for "+ getShortDescription());
        }
        if (jsonCheckPoint == null) {
          jsonCheckPoint=new HashMap<String,Object>();
          jsonCheckPoint.put("file_path",filePath);
          jsonCheckPoint.put("file_key",fileBase64);
        }
      }
 catch (      Throwable t) {
        logger.error("Error while configuring checkpoint file. Will reset file. checkPointFile=" + checkPointFile,t);
      }
    }
    setClosed(false);
    int sleepStep=2;
    int sleepIteration=0;
    while (true) {
      try {
        if (isDrain()) {
          break;
        }
        String line=br.readLine();
        if (line == null) {
          if (!resume) {
            resume=true;
          }
          sleepIteration++;
          try {
            if (sleepIteration > 4) {
              Object newFileKey=getFileKey(logPathFile);
              if (newFileKey != null) {
                if (fileKey == null || !newFileKey.equals(fileKey)) {
                  logger.info("File key is different. Calling rollover. oldKey=" + fileKey + ", newKey="+ newFileKey+ ". "+ getShortDescription());
                  rollOver();
                }
              }
            }
            if (!tail && sleepIteration >= 2) {
              logger.info("End of file. Done with filePath=" + logPathFile.getAbsolutePath() + ", lineCount="+ lineCount);
              flush();
              break;
            }
 else             if (sleepIteration == 2) {
              flush();
            }
 else             if (sleepIteration >= 2) {
              if (isRolledOver) {
                isRolledOver=false;
                try {
                  logger.info("File is rolled over. Closing current open file." + getShortDescription() + ", lineCount="+ lineCount);
                  br.close();
                }
 catch (                Exception ex) {
                  logger.error("Error closing file" + getShortDescription());
                  break;
                }
                try {
                  logger.info("Opening new rolled over file." + getShortDescription());
                  br=new BufferedReader(LogsearchReaderFactory.INSTANCE.getReader(logPathFile));
                  lineCount=0;
                  fileKey=getFileKey(logPathFile);
                  base64FileKey=Base64.byteArrayToBase64(fileKey.toString().getBytes());
                  logger.info("fileKey=" + fileKey + ", base64="+ base64FileKey+ ", "+ getShortDescription());
                }
 catch (                Exception ex) {
                  logger.error("Error opening rolled over file. " + getShortDescription());
                  logger.info("Added input to not ready list." + getShortDescription());
                  isReady=false;
                  inputMgr.addToNotReady(this);
                  break;
                }
                logger.info("File is successfully rolled over. " + getShortDescription());
                continue;
              }
            }
            Thread.sleep(sleepStep * 1000);
            sleepStep=(sleepStep * 2);
            sleepStep=sleepStep > 10 ? 10 : sleepStep;
          }
 catch (          InterruptedException e) {
            logger.info("Thread interrupted." + getShortDescription());
          }
        }
 else {
          lineCount++;
          sleepStep=1;
          sleepIteration=0;
          if (!resume && lineCount > resumeFromLineNumber) {
            logger.info("Resuming to read from last line. lineCount=" + lineCount + ", input="+ getShortDescription());
            resume=true;
          }
          if (resume) {
            InputMarker marker=new InputMarker();
            marker.fileKey=fileKey;
            marker.base64FileKey=base64FileKey;
            marker.filePath=filePath;
            marker.input=this;
            marker.lineNumber=lineCount;
            outputLine(line,marker);
          }
        }
      }
 catch (      Throwable t) {
        final String LOG_MESSAGE_KEY=this.getClass().getSimpleName() + "_READ_LOOP_EXCEPTION";
        LogFeederUtil.logErrorMessageByInterval(LOG_MESSAGE_KEY,"Caught exception in read loop. lineNumber=" + lineCount + ", input="+ getShortDescription(),t,logger,Level.ERROR);
      }
    }
  }
  finally {
    if (br != null) {
      logger.info("Closing reader." + getShortDescription() + ", lineCount="+ lineCount);
      try {
        br.close();
      }
 catch (      Throwable t) {
      }
    }
  }
}
